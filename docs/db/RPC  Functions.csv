schema,function_name,identity_args,return_type,security_definer,function_sql
auth,email,,text,false,"CREATE OR REPLACE FUNCTION auth.email()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$function$
"
auth,jwt,,jsonb,false,"CREATE OR REPLACE FUNCTION auth.jwt()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$function$
"
auth,role,,text,false,"CREATE OR REPLACE FUNCTION auth.role()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$function$
"
auth,uid,,uuid,false,"CREATE OR REPLACE FUNCTION auth.uid()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$function$
"
cron,alter_job,"job_id bigint, schedule text, command text, database text, username text, active boolean",void,false,"CREATE OR REPLACE FUNCTION cron.alter_job(job_id bigint, schedule text DEFAULT NULL::text, command text DEFAULT NULL::text, database text DEFAULT NULL::text, username text DEFAULT NULL::text, active boolean DEFAULT NULL::boolean)
 RETURNS void
 LANGUAGE c
AS '$libdir/pg_cron', $function$cron_alter_job$function$
"
cron,job_cache_invalidate,,trigger,false,"CREATE OR REPLACE FUNCTION cron.job_cache_invalidate()
 RETURNS trigger
 LANGUAGE c
AS '$libdir/pg_cron', $function$cron_job_cache_invalidate$function$
"
cron,schedule,"schedule text, command text",bigint,false,"CREATE OR REPLACE FUNCTION cron.schedule(schedule text, command text)
 RETURNS bigint
 LANGUAGE c
 STRICT
AS '$libdir/pg_cron', $function$cron_schedule$function$
"
cron,schedule,"job_name text, schedule text, command text",bigint,false,"CREATE OR REPLACE FUNCTION cron.schedule(job_name text, schedule text, command text)
 RETURNS bigint
 LANGUAGE c
AS '$libdir/pg_cron', $function$cron_schedule_named$function$
"
cron,schedule_in_database,"job_name text, schedule text, command text, database text, username text, active boolean",bigint,false,"CREATE OR REPLACE FUNCTION cron.schedule_in_database(job_name text, schedule text, command text, database text, username text DEFAULT NULL::text, active boolean DEFAULT true)
 RETURNS bigint
 LANGUAGE c
AS '$libdir/pg_cron', $function$cron_schedule_named$function$
"
cron,unschedule,job_name text,boolean,false,"CREATE OR REPLACE FUNCTION cron.unschedule(job_name text)
 RETURNS boolean
 LANGUAGE c
 STRICT
AS '$libdir/pg_cron', $function$cron_unschedule_named$function$
"
cron,unschedule,job_id bigint,boolean,false,"CREATE OR REPLACE FUNCTION cron.unschedule(job_id bigint)
 RETURNS boolean
 LANGUAGE c
 STRICT
AS '$libdir/pg_cron', $function$cron_unschedule$function$
"
extensions,armor,bytea,text,false,"CREATE OR REPLACE FUNCTION extensions.armor(bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_armor$function$
"
extensions,armor,"bytea, text[], text[]",text,false,"CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_armor$function$
"
extensions,crypt,"text, text",text,false,"CREATE OR REPLACE FUNCTION extensions.crypt(text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_crypt$function$
"
extensions,dearmor,text,bytea,false,"CREATE OR REPLACE FUNCTION extensions.dearmor(text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_dearmor$function$
"
extensions,decrypt,"bytea, bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_decrypt$function$
"
extensions,decrypt_iv,"bytea, bytea, bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$
"
extensions,digest,"text, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.digest(text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_digest$function$
"
extensions,digest,"bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_digest$function$
"
extensions,encrypt,"bytea, bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_encrypt$function$
"
extensions,encrypt_iv,"bytea, bytea, bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$
"
extensions,gen_random_bytes,integer,bytea,false,"CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_random_bytes$function$
"
extensions,gen_random_uuid,,uuid,false,"CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE
AS '$libdir/pgcrypto', $function$pg_random_uuid$function$
"
extensions,gen_salt,"text, integer",text,false,"CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)
 RETURNS text
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$
"
extensions,gen_salt,text,text,false,"CREATE OR REPLACE FUNCTION extensions.gen_salt(text)
 RETURNS text
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_gen_salt$function$
"
extensions,grant_pg_cron_access,,event_trigger,false,"CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF EXISTS (
    SELECT
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_cron'
  )
  THEN
    grant usage on schema cron to postgres with grant option;

    alter default privileges in schema cron grant all on tables to postgres with grant option;
    alter default privileges in schema cron grant all on functions to postgres with grant option;
    alter default privileges in schema cron grant all on sequences to postgres with grant option;

    alter default privileges for user supabase_admin in schema cron grant all
        on sequences to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on tables to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on functions to postgres with grant option;

    grant all privileges on all tables in schema cron to postgres with grant option;
    revoke all on table cron.job from postgres;
    grant select on table cron.job to postgres with grant option;
  END IF;
END;
$function$
"
extensions,grant_pg_graphql_access,,event_trigger,false,"CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    func_is_graphql_resolve bool;
BEGIN
    func_is_graphql_resolve = (
        SELECT n.proname = 'resolve'
        FROM pg_event_trigger_ddl_commands() AS ev
        LEFT JOIN pg_catalog.pg_proc AS n
        ON ev.objid = n.oid
    );

    IF func_is_graphql_resolve
    THEN
        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
        DROP FUNCTION IF EXISTS graphql_public.graphql;
        create or replace function graphql_public.graphql(
            ""operationName"" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language sql
        as $$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                ""operationName"" := ""operationName"",
                extensions := extensions
            );
        $$;

        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
        -- function in the extension so we need to grant permissions on existing entities AND
        -- update default permissions to any others that are created after `graphql.resolve`
        grant usage on schema graphql to postgres, anon, authenticated, service_role;
        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles
        grant usage on schema graphql_public to postgres with grant option;
        grant usage on schema graphql to postgres with grant option;
    END IF;

END;
$function$
"
extensions,grant_pg_net_access,,event_trigger,false,"CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
  BEGIN
    IF EXISTS (
      SELECT 1
      FROM pg_event_trigger_ddl_commands() AS ev
      JOIN pg_extension AS ext
      ON ev.objid = ext.oid
      WHERE ext.extname = 'pg_net'
    )
    THEN
      GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

      IF EXISTS (
        SELECT FROM pg_extension
        WHERE extname = 'pg_net'
        -- all versions in use on existing projects as of 2025-02-20
        -- version 0.12.0 onwards don't need these applied
        AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')
      ) THEN
        ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
        ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

        ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
        ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

        REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
        REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

        GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
        GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
      END IF;
    END IF;
  END;
  $function$
"
extensions,hmac,"text, text, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_hmac$function$
"
extensions,hmac,"bytea, bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_hmac$function$
"
extensions,pg_stat_statements,"showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone",SETOF record,false,"CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone)
 RETURNS SETOF record
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_11$function$
"
extensions,pg_stat_statements_info,"OUT dealloc bigint, OUT stats_reset timestamp with time zone",record,false,"CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)
 RETURNS record
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$
"
extensions,pg_stat_statements_reset,"userid oid, dbid oid, queryid bigint, minmax_only boolean",timestamp with time zone,false,"CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0, minmax_only boolean DEFAULT false)
 RETURNS timestamp with time zone
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_11$function$
"
extensions,pgp_armor_headers,"text, OUT key text, OUT value text",SETOF record,false,"CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)
 RETURNS SETOF record
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_armor_headers$function$
"
extensions,pgp_key_id,bytea,text,false,"CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_key_id_w$function$
"
extensions,pgp_pub_decrypt,"bytea, bytea",text,false,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
"
extensions,pgp_pub_decrypt,"bytea, bytea, text, text",text,false,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
"
extensions,pgp_pub_decrypt,"bytea, bytea, text",text,false,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
"
extensions,pgp_pub_decrypt_bytea,"bytea, bytea, text, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
"
extensions,pgp_pub_decrypt_bytea,"bytea, bytea",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
"
extensions,pgp_pub_decrypt_bytea,"bytea, bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
"
extensions,pgp_pub_encrypt,"text, bytea",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$
"
extensions,pgp_pub_encrypt,"text, bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$
"
extensions,pgp_pub_encrypt_bytea,"bytea, bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$
"
extensions,pgp_pub_encrypt_bytea,"bytea, bytea",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$
"
extensions,pgp_sym_decrypt,"bytea, text",text,false,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$
"
extensions,pgp_sym_decrypt,"bytea, text, text",text,false,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$
"
extensions,pgp_sym_decrypt_bytea,"bytea, text, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$
"
extensions,pgp_sym_decrypt_bytea,"bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$
"
extensions,pgp_sym_encrypt,"text, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$
"
extensions,pgp_sym_encrypt,"text, text, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$
"
extensions,pgp_sym_encrypt_bytea,"bytea, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$
"
extensions,pgp_sym_encrypt_bytea,"bytea, text, text",bytea,false,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$
"
extensions,pgrst_ddl_watch,,event_trigger,false,"CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
  LOOP
    IF cmd.command_tag IN (
      'CREATE SCHEMA', 'ALTER SCHEMA'
    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
    , 'CREATE VIEW', 'ALTER VIEW'
    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
    , 'CREATE FUNCTION', 'ALTER FUNCTION'
    , 'CREATE TRIGGER'
    , 'CREATE TYPE', 'ALTER TYPE'
    , 'CREATE RULE'
    , 'COMMENT'
    )
    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
    AND cmd.schema_name is distinct from 'pg_temp'
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $function$
"
extensions,pgrst_drop_watch,,event_trigger,false,"CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  obj record;
BEGIN
  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
  LOOP
    IF obj.object_type IN (
      'schema'
    , 'table'
    , 'foreign table'
    , 'view'
    , 'materialized view'
    , 'function'
    , 'trigger'
    , 'type'
    , 'rule'
    )
    AND obj.is_temporary IS false -- no pg_temp objects
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $function$
"
extensions,set_graphql_placeholder,,event_trigger,false,"CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
    DECLARE
    graphql_is_dropped bool;
    BEGIN
    graphql_is_dropped = (
        SELECT ev.schema_name = 'graphql_public'
        FROM pg_event_trigger_dropped_objects() AS ev
        WHERE ev.schema_name = 'graphql_public'
    );

    IF graphql_is_dropped
    THEN
        create or replace function graphql_public.graphql(
            ""operationName"" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language plpgsql
        as $$
            DECLARE
                server_version float;
            BEGIN
                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

                IF server_version >= 14 THEN
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql extension is not enabled.'
                            )
                        )
                    );
                ELSE
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
                            )
                        )
                    );
                END IF;
            END;
        $$;
    END IF;

    END;
$function$
"
extensions,uuid_generate_v1,,uuid,false,"CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$
"
extensions,uuid_generate_v1mc,,uuid,false,"CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$
"
extensions,uuid_generate_v3,"namespace uuid, name text",uuid,false,"CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$
"
extensions,uuid_generate_v4,,uuid,false,"CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$
"
extensions,uuid_generate_v5,"namespace uuid, name text",uuid,false,"CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$
"
extensions,uuid_nil,,uuid,false,"CREATE OR REPLACE FUNCTION extensions.uuid_nil()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_nil$function$
"
extensions,uuid_ns_dns,,uuid,false,"CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$
"
extensions,uuid_ns_oid,,uuid,false,"CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$
"
extensions,uuid_ns_url,,uuid,false,"CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_url$function$
"
extensions,uuid_ns_x500,,uuid,false,"CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$
"
graphql,_internal_resolve,"query text, variables jsonb, ""operationName"" text, extensions jsonb",jsonb,false,"CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, ""operationName"" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)
 RETURNS jsonb
 LANGUAGE c
AS '$libdir/pg_graphql', $function$resolve_wrapper$function$
"
graphql,comment_directive,comment_ text,jsonb,false,"CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)
 RETURNS jsonb
 LANGUAGE sql
 IMMUTABLE
AS $function$
    /*
    comment on column public.account.name is '@graphql.name: myField'
    */
    select
        coalesce(
            (
                regexp_match(
                    comment_,
                    '@graphql\((.+)\)'
                )
            )[1]::jsonb,
            jsonb_build_object()
        )
$function$
"
graphql,exception,message text,text,false,"CREATE OR REPLACE FUNCTION graphql.exception(message text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
begin
    raise exception using errcode='22000', message=message;
end;
$function$
"
graphql,get_schema_version,,integer,true,"CREATE OR REPLACE FUNCTION graphql.get_schema_version()
 RETURNS integer
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
    select last_value from graphql.seq_schema_version;
$function$
"
graphql,increment_schema_version,,event_trigger,true,"CREATE OR REPLACE FUNCTION graphql.increment_schema_version()
 RETURNS event_trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
    perform pg_catalog.nextval('graphql.seq_schema_version');
end;
$function$
"
graphql,resolve,"query text, variables jsonb, ""operationName"" text, extensions jsonb",jsonb,false,"CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, ""operationName"" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
declare
    res jsonb;
    message_text text;
begin
  begin
    select graphql._internal_resolve(""query"" := ""query"",
                                     ""variables"" := ""variables"",
                                     ""operationName"" := ""operationName"",
                                     ""extensions"" := ""extensions"") into res;
    return res;
  exception
    when others then
    get stacked diagnostics message_text = message_text;
    return
    jsonb_build_object('data', null,
                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));
  end;
end;
$function$
"
graphql_public,graphql,"""operationName"" text, query text, variables jsonb, extensions jsonb",jsonb,false,"CREATE OR REPLACE FUNCTION graphql_public.graphql(""operationName"" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)
 RETURNS jsonb
 LANGUAGE sql
AS $function$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                ""operationName"" := ""operationName"",
                extensions := extensions
            );
        $function$
"
net,_await_response,request_id bigint,boolean,false,"CREATE OR REPLACE FUNCTION net._await_response(request_id bigint)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
declare
    rec net._http_response;
begin
    while rec is null loop
        select *
        into rec
        from net._http_response
        where id = request_id;

        if rec is null then
            -- Wait 50 ms before checking again
            perform pg_sleep(0.05);
        end if;
    end loop;

    return true;
end;
$function$
"
net,_encode_url_with_params_array,"url text, params_array text[]",text,false,"CREATE OR REPLACE FUNCTION net._encode_url_with_params_array(url text, params_array text[])
 RETURNS text
 LANGUAGE c
 IMMUTABLE
AS 'pg_net', $function$_encode_url_with_params_array$function$
"
net,_http_collect_response,"request_id bigint, async boolean",net.http_response_result,false,"CREATE OR REPLACE FUNCTION net._http_collect_response(request_id bigint, async boolean DEFAULT true)
 RETURNS net.http_response_result
 LANGUAGE plpgsql
AS $function$
declare
    rec net._http_response;
    req_exists boolean;
begin

    if not async then
        perform net._await_response(request_id);
    end if;

    select *
    into rec
    from net._http_response
    where id = request_id;

    if rec is null or rec.error_msg is not null then
        -- The request is either still processing or the request_id provided does not exist

        -- TODO: request in progress is indistinguishable from request that doesn't exist

        -- No request matching request_id found
        return (
            'ERROR',
            coalesce(rec.error_msg, 'request matching request_id not found'),
            null
        )::net.http_response_result;

    end if;

    -- Return a valid, populated http_response_result
    return (
        'SUCCESS',
        'ok',
        (
            rec.status_code,
            rec.headers,
            rec.content
        )::net.http_response
    )::net.http_response_result;
end;
$function$
"
net,_urlencode_string,string character varying,text,false,"CREATE OR REPLACE FUNCTION net._urlencode_string(string character varying)
 RETURNS text
 LANGUAGE c
 IMMUTABLE
AS 'pg_net', $function$_urlencode_string$function$
"
net,check_worker_is_up,,void,false,"CREATE OR REPLACE FUNCTION net.check_worker_is_up()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
begin
  if not exists (select pid from pg_stat_activity where backend_type ilike '%pg_net%') then
    raise exception using
      message = 'the pg_net background worker is not up'
    , detail  = 'the pg_net background worker is down due to an internal error and cannot process requests'
    , hint    = 'make sure that you didn''t modify any of pg_net internal tables';
  end if;
end
$function$
"
net,http_collect_response,"request_id bigint, async boolean",net.http_response_result,false,"CREATE OR REPLACE FUNCTION net.http_collect_response(request_id bigint, async boolean DEFAULT true)
 RETURNS net.http_response_result
 LANGUAGE plpgsql
AS $function$
begin
  raise notice 'The net.http_collect_response function is deprecated.';
  select net._http_collect_response(request_id, async);
end;
$function$
"
net,http_delete,"url text, params jsonb, headers jsonb, timeout_milliseconds integer, body jsonb",bigint,false,"CREATE OR REPLACE FUNCTION net.http_delete(url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000, body jsonb DEFAULT NULL::jsonb)
 RETURNS bigint
 LANGUAGE plpgsql
AS $function$
declare
    request_id bigint;
    params_array text[];
begin
    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')
    into params_array
    from jsonb_each_text(params);

    -- Add to the request queue
    insert into net.http_request_queue(method, url, headers, body, timeout_milliseconds)
    values (
        'DELETE',
        net._encode_url_with_params_array(url, params_array),
        headers,
        convert_to(body::text, 'UTF8'),
        timeout_milliseconds
    )
    returning id
    into request_id;

    perform net.wake();

    return request_id;
end
$function$
"
net,http_get,"url text, params jsonb, headers jsonb, timeout_milliseconds integer",bigint,false,"CREATE OR REPLACE FUNCTION net.http_get(url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000)
 RETURNS bigint
 LANGUAGE plpgsql
AS $function$
declare
    request_id bigint;
    params_array text[];
begin
    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')
    into params_array
    from jsonb_each_text(params);

    -- Add to the request queue
    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)
    values (
        'GET',
        net._encode_url_with_params_array(url, params_array),
        headers,
        timeout_milliseconds
    )
    returning id
    into request_id;

    perform net.wake();

    return request_id;
end
$function$
"
net,http_post,"url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer",bigint,false,"CREATE OR REPLACE FUNCTION net.http_post(url text, body jsonb DEFAULT '{}'::jsonb, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{""Content-Type"": ""application/json""}'::jsonb, timeout_milliseconds integer DEFAULT 5000)
 RETURNS bigint
 LANGUAGE plpgsql
AS $function$
declare
    request_id bigint;
    params_array text[];
    content_type text;
begin

    -- Exctract the content_type from headers
    select
        header_value into content_type
    from
        jsonb_each_text(coalesce(headers, '{}'::jsonb)) r(header_name, header_value)
    where
        lower(header_name) = 'content-type'
    limit
        1;

    -- If the user provided new headers and omitted the content type
    -- add it back in automatically
    if content_type is null then
        select headers || '{""Content-Type"": ""application/json""}'::jsonb into headers;
    end if;

    -- Confirm that the content-type is set as ""application/json""
    if content_type <> 'application/json' then
        raise exception 'Content-Type header must be ""application/json""';
    end if;

    select
        coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')
    into
        params_array
    from
        jsonb_each_text(params);

    -- Add to the request queue
    insert into net.http_request_queue(method, url, headers, body, timeout_milliseconds)
    values (
        'POST',
        net._encode_url_with_params_array(url, params_array),
        headers,
        convert_to(body::text, 'UTF8'),
        timeout_milliseconds
    )
    returning id
    into request_id;

    perform net.wake();

    return request_id;
end
$function$
"
net,wait_until_running,,void,false,"CREATE OR REPLACE FUNCTION net.wait_until_running()
 RETURNS void
 LANGUAGE c
AS 'pg_net', $function$wait_until_running$function$
"
net,wake,,void,false,"CREATE OR REPLACE FUNCTION net.wake()
 RETURNS void
 LANGUAGE c
AS 'pg_net', $function$wake$function$
"
net,worker_restart,,boolean,false,"CREATE OR REPLACE FUNCTION net.worker_restart()
 RETURNS boolean
 LANGUAGE c
AS 'pg_net', $function$worker_restart$function$
"
pgbouncer,get_auth,p_usename text,"TABLE(username text, password text)",true,"CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)
 RETURNS TABLE(username text, password text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
  BEGIN
      RAISE DEBUG 'PgBouncer auth request: %', p_usename;

      RETURN QUERY
      SELECT
          rolname::text,
          CASE WHEN rolvaliduntil < now()
              THEN null
              ELSE rolpassword::text
          END
      FROM pg_authid
      WHERE rolname=$1 and rolcanlogin;
  END;
  $function$
"
public,_set_updated_at,,trigger,false,"CREATE OR REPLACE FUNCTION public._set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end;
$function$
"
public,_upsert_notification,"p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb",void,true,"CREATE OR REPLACE FUNCTION public._upsert_notification(p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- Prevent self notifications
  if p_user_id is null or p_actor_id is null then
    return;
  end if;
  if p_user_id = p_actor_id then
    return;
  end if;

  insert into public.notifications (user_id, actor_id, type, entity_type, entity_id, payload, is_read, read_at, created_at)
  values (p_user_id, p_actor_id, p_type, p_entity_type, p_entity_id, p_payload, false, null, now())
  on conflict (user_id, type, actor_id, entity_id)
  do update set
    payload   = excluded.payload,
    is_read   = false,
    read_at   = null,
    created_at = now();
end;
$function$
"
public,actor_snapshot,p_actor_id uuid,jsonb,false,"CREATE OR REPLACE FUNCTION public.actor_snapshot(p_actor_id uuid)
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select jsonb_build_object(
    'actor_id', p.id,
    'actor_username', p.username,
    'actor_display_name', coalesce(nullif(trim(p.display_name), ''), 'אנונימי'),
    'actor_avatar_url', p.avatar_url
  )
  from public.profiles p
  where p.id = p_actor_id
$function$
"
public,admin_delete_community_note,"p_note_id uuid, p_reason text",void,true,"CREATE OR REPLACE FUNCTION public.admin_delete_community_note(p_note_id uuid, p_reason text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_admin_id uuid := auth.uid();
  v_note record;
begin
  if v_admin_id is null then
    raise exception 'not_authenticated';
  end if;

  if not exists (
    select 1 from public.admins where user_id = v_admin_id
  ) then
    raise exception 'not_admin';
  end if;

  if p_reason is null or length(trim(p_reason)) < 3 then
    raise exception 'reason_required';
  end if;

  select id, user_id, body
  into v_note
  from public.community_notes
  where id = p_note_id;

  if not found then
    raise exception 'note_not_found';
  end if;

  -- notification לבעל הפתק
  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read
  ) values (
    v_note.user_id,
    null,
    'system_message',
    'community_note',
    v_note.id,
    jsonb_build_object(
      'action', 'note_deleted',
      'note_snippet', left(regexp_replace(coalesce(v_note.body,''), E'\\s+', ' ', 'g'), 60),
      'reason', trim(p_reason)
    ),
    false
  );

  delete from public.community_notes
  where id = p_note_id;
end;
$function$
"
public,cleanup_expired_community_notes,,bigint,true,"CREATE OR REPLACE FUNCTION public.cleanup_expired_community_notes()
 RETURNS bigint
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  with del as (
    delete from public.community_notes
    where updated_at < now() - interval '12 hours'
    returning 1
  )
  select count(*)::bigint from del;
$function$
"
public,cleanup_notification_on_comment_unlike,,trigger,true,"CREATE OR REPLACE FUNCTION public.cleanup_notification_on_comment_unlike()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  delete from public.notifications n
  where (n.payload->>'action') = 'comment_like'
    and (n.payload->>'comment_id') = old.comment_id::text
    and (n.payload->>'from_user_id') = old.user_id::text;

  return old;
end;
$function$
"
public,cleanup_notifications_on_comment_delete,,trigger,true,"CREATE OR REPLACE FUNCTION public.cleanup_notifications_on_comment_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- מוחק כל notification שמצביע על comment_id הזה בתוך payload
  delete from public.notifications n
  where (n.payload->>'comment_id') = old.id::text
     or (n.entity_id is not null and n.entity_id::text = old.id::text);

  return old;
end;
$function$
"
public,enforce_max_3_reactions,,trigger,false,"CREATE OR REPLACE FUNCTION public.enforce_max_3_reactions()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  cnt int;
begin
  select count(*) into cnt
  from public.post_reaction_votes
  where post_id = new.post_id and voter_id = new.voter_id;

  if cnt >= 3 then
    raise exception 'Max 3 reactions per post';
  end if;

  return new;
end;
$function$
"
public,get_my_conversations,,"TABLE(conversation_id uuid, other_username text, other_display_name text, other_avatar_url text, last_message_body text, last_message_at timestamp with time zone, unread_count integer)",true,"CREATE OR REPLACE FUNCTION public.get_my_conversations()
 RETURNS TABLE(conversation_id uuid, other_username text, other_display_name text, other_avatar_url text, last_message_body text, last_message_at timestamp with time zone, unread_count integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  select
    t.conversation_id,
    t.other_username,
    t.other_display_name,
    t.other_avatar_url,
    t.last_message_body,
    t.last_message_at,
    t.unread_count
  from public.inbox_threads t
  order by t.last_message_at desc nulls last;
$function$
"
public,get_profile_reaction_totals,p_profile_id uuid,"TABLE(reaction_key text, label_he text, total_votes integer, sort_order integer)",false,"CREATE OR REPLACE FUNCTION public.get_profile_reaction_totals(p_profile_id uuid)
 RETURNS TABLE(reaction_key text, label_he text, total_votes integer, sort_order integer)
 LANGUAGE sql
 STABLE
AS $function$
  select
    r.key as reaction_key,
    r.label_he,
    coalesce(t.total_votes, 0)::int as total_votes,
    r.sort_order
  from public.reactions r
  left join public.profile_reaction_totals t
    on t.profile_id = p_profile_id
   and t.reaction_key = r.key
  where r.is_active = true
  order by r.sort_order asc;
$function$
"
public,handle_new_user,,trigger,true,"CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_display_name text;
  v_username text;
begin
  v_display_name := coalesce(new.raw_user_meta_data->>'display_name', 'משתמש');

  -- use provided username if exists, else generate one
  v_username := nullif(new.raw_user_meta_data->>'username', '');
  if v_username is null then
    v_username := 'user_' || substr(replace(new.id::text, '-', ''), 1, 10);
  end if;

  insert into public.profiles (id, display_name, username, avatar_url)
  values (
    new.id,
    v_display_name,
    v_username,
    'https://api.dicebear.com/7.x/initials/svg?seed=' || v_display_name
  )
  on conflict (id) do nothing;

  return new;
end;
$function$
"
public,insert_notification,"p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb",void,true,"CREATE OR REPLACE FUNCTION public.insert_notification(p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read,
    created_at,
    read_at
  )
  values (
    p_user_id,
    p_actor_id,
    p_type,
    p_entity_type,
    p_entity_id,
    coalesce(p_payload, '{}'::jsonb),
    false,
    now(),
    null
  )
  on conflict on constraint notifications_unique_event
  do update set
    payload = excluded.payload,
    is_read = false,
    read_at = null,
    created_at = now();
end;
$function$
"
public,insert_notification_upsert,"p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb",void,true,"CREATE OR REPLACE FUNCTION public.insert_notification_upsert(p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  insert into public.notifications (
    user_id, actor_id, type, entity_type, entity_id, payload, is_read, created_at, read_at
  )
  values (
    p_user_id,
    p_actor_id,
    p_type,
    p_entity_type,
    p_entity_id,
    coalesce(p_payload, '{}'::jsonb),
    false,
    now(),
    null
  )
  on conflict on constraint notifications_unique_event
  do update set
    payload    = excluded.payload,
    is_read    = false,
    read_at    = null,
    created_at = now();
end;
$function$
"
public,is_user_suspended,p_user_id uuid,boolean,false,"CREATE OR REPLACE FUNCTION public.is_user_suspended(p_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  select coalesce((select is_suspended from public.user_moderation where user_id = p_user_id), false);
$function$
"
public,limit_three_ratings_per_post,,trigger,false,"CREATE OR REPLACE FUNCTION public.limit_three_ratings_per_post()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  cnt int;
begin
  select count(*) into cnt
  from public.post_votes
  where post_id = new.post_id and voter_id = new.voter_id;

  if cnt >= 3 then
    raise exception 'Max 3 ratings per post per user';
  end if;

  return new;
end;
$function$
"
public,mark_conversation_read,p_conversation_id uuid,void,true,"CREATE OR REPLACE FUNCTION public.mark_conversation_read(p_conversation_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  update public.messages
  set read_at = now()
  where conversation_id = p_conversation_id
    and sender_id <> auth.uid()
    and read_at is null;
end;
$function$
"
public,notify_comment_delete,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_comment_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  post_author uuid;
  remaining int;
begin
  select p.author_id
    into post_author
  from public.posts p
  where p.id = old.post_id;

  if post_author is null then
    return old;
  end if;

  -- if the same actor still has comments on this post -> keep notification
  select count(*) into remaining
  from public.comments c
  where c.post_id = old.post_id
    and c.author_id = old.author_id;

  if remaining = 0 then
    delete from public.notifications n
    where n.user_id   = post_author
      and n.actor_id  = old.author_id
      and n.type      = 'comment'
      and n.entity_type = 'post'
      and n.entity_id = old.post_id;
  end if;

  return old;
end;
$function$
"
public,notify_comment_insert,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_comment_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  post_owner uuid;
  post_slug text;
  post_title text;
begin
  -- מביאים את בעל הפוסט + נתוני פוסט בסיסיים
  select p.author_id, p.slug, p.title
    into post_owner, post_slug, post_title
  from public.posts p
  where p.id = new.post_id;

  -- אם לא מצאנו פוסט - אין מה לעשות
  if post_owner is null then
    return new;
  end if;

  -- לא מודיעים לעצמך
  if post_owner = new.author_id then
    return new;
  end if;

  -- התראה לבעל הפוסט על תגובה חדשה (גם אם זו reply, עדיין אפשר להשאיר – אם אתם רוצים רק top-level תגיד לי)
  insert into public.notifications (user_id, type, entity_type, entity_id, payload)
  values (
    post_owner,
    'comment',
    'comment',
    new.id,
    jsonb_build_object(
      'action', case when new.parent_comment_id is null then 'comment' else 'comment_reply' end,
      'post_id', new.post_id::text,
      'post_slug', coalesce(post_slug, ''),
      'post_title', coalesce(post_title, ''),
      'comment_id', new.id::text,
      'parent_comment_id', coalesce(new.parent_comment_id::text, null),
      'comment_text', new.content,
      'from_user_id', new.author_id::text
    )
  );

  return new;
end;
$function$
"
public,notify_comment_like,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_comment_like()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_comment_author uuid;
  v_post_id uuid;
  v_post_slug text;
  v_post_title text;
begin
  select c.author_id, c.post_id
    into v_comment_author, v_post_id
  from public.comments c
  where c.id = new.comment_id;

  if v_comment_author is null then
    return new;
  end if;

  if v_comment_author = new.user_id then
    return new;
  end if;

  select p.slug, p.title
    into v_post_slug, v_post_title
  from public.posts p
  where p.id = v_post_id;

  insert into public.notifications (
    user_id, actor_id, type, entity_type, entity_id, payload, is_read, created_at
  )
  values (
    v_comment_author,
    new.user_id,
    'comment',              -- ✅ type חוקי
    'comment',
    new.comment_id,
    jsonb_build_object(
      'action', 'comment_like',     -- ✅ ככה ה-UI מבדיל שזה לייק לתגובה
      'post_id', v_post_id,
      'post_slug', v_post_slug,
      'post_title', v_post_title,
      'comment_id', new.comment_id
    ),
    false,
    now()
  )
  on conflict on constraint notifications_unique_event do nothing;

  return new;
end;
$function$
"
public,notify_follow,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_follow()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- חשוב: מאפשר לפונקציה לעבוד גם כש-RLS דלוק על notifications
  perform set_config('row_security', 'off', true);

  -- לא שולחים התראה על follow לעצמי (אם איכשהו קרה)
  if new.follower_id = new.following_id then
    return new;
  end if;

  if tg_op = 'INSERT' then
    insert into public.notifications (user_id, type, actor_id, entity_id)
    values (new.following_id, 'follow', new.follower_id, null)
    on conflict on constraint notifications_unique_event do nothing;

    return new;
  end if;

  if tg_op = 'DELETE' then
    delete from public.notifications n
    where n.user_id = old.following_id
      and n.type = 'follow'
      and n.actor_id = old.follower_id
      and n.entity_id is null;

    return old;
  end if;

  return null;
end;
$function$
"
public,notify_follow_delete,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_follow_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- remove follow notification when unfollow
  delete from public.notifications n
  where n.user_id   = old.following_id
    and n.actor_id  = old.follower_id
    and n.type      = 'follow'
    and n.entity_id = old.following_id;

  return old;
end;
$function$
"
public,notify_follow_insert,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_follow_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  actor_username text;
  actor_display_name text;
begin
  select p.username,
         coalesce(nullif(trim(p.display_name), ''), p.username)
    into actor_username, actor_display_name
  from public.profiles p
  where p.id = new.follower_id;

  perform public._upsert_notification(
    new.following_id,
    new.follower_id,
    'follow',
    'profile',
    new.following_id,
    jsonb_build_object(
      'actor_username', actor_username,
      'actor_display_name', actor_display_name
    )
  );

  return new;
end;
$function$
"
public,notify_followers_new_post,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_followers_new_post()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  is_publish_event boolean;
begin
  if tg_op = 'INSERT' then
    is_publish_event := (new.status = 'published');
  elsif tg_op = 'UPDATE' then
    is_publish_event := (old.status is distinct from 'published' and new.status = 'published');
  else
    is_publish_event := false;
  end if;

  if not is_publish_event then
    return new;
  end if;

  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read,
    created_at
  )
  select
    uf.follower_id,
    new.author_id,
    'new_post',
    'post',
    new.id,
    jsonb_build_object(
      'post_id', new.id,
      'post_slug', new.slug,
      'post_title', new.title,
      'author_id', new.author_id
    ),
    false,
    now()
  from public.user_follows uf
  where uf.following_id = new.author_id
    and uf.follower_id <> new.author_id
  on conflict (user_id, type, entity_type, entity_id)
  where type = 'new_post' and entity_type = 'post'
  do nothing;

  return new;
end;
$function$
"
public,notify_message_insert,,trigger,false,"CREATE OR REPLACE FUNCTION public.notify_message_insert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  recipient uuid;
begin
  select cp.user_id into recipient
  from public.conversation_participants cp
  where cp.conversation_id = new.conversation_id
    and cp.user_id <> new.sender_id
  limit 1;

  if recipient is null then
    return new;
  end if;

  insert into public.notifications (user_id, type, actor_id, entity_id)
  values (recipient, 'message', new.sender_id, new.conversation_id);

  return new;
end;
$function$
"
public,notify_on_comment,,trigger,false,"CREATE OR REPLACE FUNCTION public.notify_on_comment()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  post_author uuid;
BEGIN
  -- מי בעל הפוסט
  SELECT author_id
  INTO post_author
  FROM posts
  WHERE id = NEW.post_id;

  -- לא שולחים התראה לעצמך
  IF post_author = NEW.author_id THEN
    RETURN NEW;
  END IF;

  INSERT INTO notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload
  )
  VALUES (
    post_author,
    NEW.author_id,
    'comment',
    'post',
    NEW.post_id,
    jsonb_build_object(
      'comment_id', NEW.id
    )
  )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
END;
$function$
"
public,notify_on_comment_insert,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_on_comment_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  post_author uuid;
  post_slug text;
  actor_u text;
  actor_dn text;
begin
  select p.author_id, p.slug
  into post_author, post_slug
  from public.posts p
  where p.id = new.post_id;

  if post_author is null then
    return new;
  end if;

  if post_author = new.author_id then
    return new;
  end if;

  select pr.username, coalesce(nullif(trim(pr.display_name), ''), pr.username)
  into actor_u, actor_dn
  from public.profiles pr
  where pr.id = new.author_id;

  perform public.upsert_notification(
    post_author,
    new.author_id,
    'comment',
    'post',
    new.post_id,
    jsonb_build_object(
      'post_id', new.post_id,
      'post_slug', post_slug,
      'comment_preview', left(new.content, 80),
      'actor_username', actor_u,
      'actor_display_name', actor_dn
    )
  );

  return new;
end;
$function$
"
public,notify_on_comment_insert_fn,,trigger,false,"CREATE OR REPLACE FUNCTION public.notify_on_comment_insert_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  v_post_author uuid;
  v_parent_author uuid;
  v_post_slug text;
  v_post_title text;
begin
  -- בעל הפוסט + נתוני פוסט לניווט/טקסט
  select p.author_id, p.slug, p.title
    into v_post_author, v_post_slug, v_post_title
  from public.posts p
  where p.id = new.post_id;

  if v_post_author is null then
    return new;
  end if;

  -- 1) התראה לבעל הפוסט (גם אם זו תגובת-משנה)
  if v_post_author <> new.author_id then
    perform public.insert_notification(
      v_post_author,
      new.author_id,
      'comment',
      'comment',
      new.id,
      jsonb_build_object(
        'post_id', new.post_id,
        'post_slug', v_post_slug,
        'post_title', v_post_title,
        'comment_id', new.id
      )
    );
  end if;

  -- 2) אם זו תגובה לתגובה: התראה לבעל התגובה ההורה (B)
  if new.parent_comment_id is not null then
    select c.author_id
      into v_parent_author
    from public.comments c
    where c.id = new.parent_comment_id;

    if v_parent_author is not null
       and v_parent_author <> new.author_id
       and v_parent_author <> v_post_author then
      perform public.insert_notification(
        v_parent_author,
        new.author_id,
        'comment',
        'comment',
        new.id,
        jsonb_build_object(
          'post_id', new.post_id,
          'post_slug', v_post_slug,
          'post_title', v_post_title,
          'comment_id', new.id,
          'parent_comment_id', new.parent_comment_id
        )
      );
    end if;
  end if;

  return new;
end;
$function$
"
public,notify_on_comment_like,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_on_comment_like()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_comment_owner uuid;
  v_post_id uuid;
  v_post_title text;
  v_liker_name text;
  v_type text;
begin
  -- Fetch comment owner + post_id from comments table (NOT post_comments)
  select c.author_id, c.post_id
    into v_comment_owner, v_post_id
  from public.comments c
  where c.id = new.comment_id;

  if v_comment_owner is null then
    return new;
  end if;

  -- Don't notify on self-like
  if v_comment_owner = new.user_id then
    return new;
  end if;

  -- pick a notifications.type that passes the CHECK constraint:
  -- try to reuse an existing value already stored in notifications
  select n.type into v_type
  from public.notifications n
  where n.type is not null
  limit 1;

  if v_type is null then
    v_type := 'reaction';
  end if;

  -- liker display name
  select coalesce(p.display_name, p.username, 'משתמש/ת')
    into v_liker_name
  from public.profiles p
  where p.id = new.user_id;

  -- post title (optional)
  select coalesce(p2.title, 'ללא כותרת')
    into v_post_title
  from public.posts p2
  where p2.id = v_post_id;

  insert into public.notifications (user_id, type, payload)
  values (
    v_comment_owner,
    v_type,
    jsonb_build_object(
      'action', 'comment_like',
      'from_user_id', new.user_id,
      'from_user_name', v_liker_name,
      'post_id', v_post_id,
      'post_title', v_post_title,
      'comment_id', new.comment_id
    )
  );

  return new;
end;
$function$
"
public,notify_on_comment_reply,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_on_comment_reply()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  parent_owner uuid;
begin
  -- רק אם זו תגובת reply
  if new.parent_comment_id is null then
    return new;
  end if;

  -- בעל התגובה שאליה עונים
  select c.author_id into parent_owner
  from public.comments c
  where c.id = new.parent_comment_id;

  -- אין parent / או reply לעצמך -> לא מודיעים
  if parent_owner is null or parent_owner = new.author_id then
    return new;
  end if;

  -- מוסיפים notification לבעל התגובה המקורית
  insert into public.notifications (user_id, type, payload, entity_id)
  values (
    parent_owner,
    'comment',
    jsonb_build_object(
      'action', 'comment_reply',
      'comment_id', new.id::text,                  -- ה-reply החדש (בשביל highlight)
      'parent_comment_id', new.parent_comment_id::text,
      'post_id', new.post_id::text,
      'from_user_id', new.author_id::text
    ),
    new.id
  );

  return new;
end;
$function$
"
public,notify_on_follow,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_on_follow()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_payload jsonb;
begin
  -- לא שולחים התראה אם משתמש עוקב אחרי עצמו (ליתר ביטחון)
  if new.follower_id = new.following_id then
    return new;
  end if;

  v_payload :=
    jsonb_build_object(
      'following_id', new.following_id,
      'follower_id', new.follower_id
    )
    || coalesce(public.actor_snapshot(new.follower_id), '{}'::jsonb);

  perform public.insert_notification_upsert(
    new.following_id,          -- מקבל ההתראה
    new.follower_id,           -- מי עשה את הפעולה
    'follow',
    'profile',
    new.follower_id,           -- entity_id: מי שעוקב (או אפשר following_id — לא קריטי כל עוד עקבי)
    v_payload
  );

  return new;
end;
$function$
"
public,notify_on_follow_insert,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_on_follow_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  actor_display text;
  actor_username text;
begin
  -- לא שולחים התראה על self-follow (ליתר ביטחון)
  if new.follower_id = new.following_id then
    return new;
  end if;

  select
    coalesce(nullif(trim(p.display_name), ''), p.username, 'מישהו'),
    p.username
  into actor_display, actor_username
  from public.profiles p
  where p.id = new.follower_id;

  insert into public.notifications (user_id, actor_id, type, entity_type, entity_id, payload, is_read)
  values (
    new.following_id,
    new.follower_id,
    'follow',
    'profile',
    new.follower_id,
    jsonb_build_object(
      'actor_display_name', actor_display,
      'actor_username', actor_username
    ),
    false
  )
  on conflict (user_id, type, actor_id, entity_id) do update
    set created_at = now(),
        is_read = false,
        payload = excluded.payload;

  return new;
end $function$
"
public,notify_on_reaction,,trigger,false,"CREATE OR REPLACE FUNCTION public.notify_on_reaction()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  post_author uuid;
BEGIN
  SELECT author_id
  INTO post_author
  FROM posts
  WHERE id = NEW.post_id;

  IF post_author = NEW.voter_id THEN
    RETURN NEW;
  END IF;

  INSERT INTO notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload
  )
  VALUES (
    post_author,
    NEW.voter_id,
    'reaction',
    'post',
    NEW.post_id,
    jsonb_build_object(
      'reaction', NEW.reaction_key
    )
  )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
END;
$function$
"
public,notify_on_reaction_insert,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_on_reaction_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_post_author uuid;
  v_post_slug text;
  v_actor_username text;
  v_actor_display text;
BEGIN
  -- מי בעל הפוסט?
  SELECT author_id, slug
    INTO v_post_author, v_post_slug
  FROM public.posts
  WHERE id = NEW.post_id;

  IF v_post_author IS NULL THEN
    RETURN NEW;
  END IF;

  -- לא שולחים התראה על ריאקשן לעצמך
  IF v_post_author = NEW.voter_id THEN
    RETURN NEW;
  END IF;

  -- פרטי השחקן (מי שעשה)
  SELECT username, COALESCE(NULLIF(trim(display_name), ''), username)
    INTO v_actor_username, v_actor_display
  FROM public.profiles
  WHERE id = NEW.voter_id;

  INSERT INTO public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read
  )
  VALUES (
    v_post_author,
    NEW.voter_id,
    'reaction',
    'post',
    NEW.post_id,
    jsonb_build_object(
      'post_id', NEW.post_id,
      'post_slug', v_post_slug,
      'reaction_key', NEW.reaction_key,
      'actor_username', v_actor_username,
      'actor_display_name', v_actor_display
    ),
    false
  )
  ON CONFLICT (user_id, type, actor_id, entity_id) DO UPDATE
    SET created_at = now(),
        is_read = false,
        read_at = null,
        payload = EXCLUDED.payload;

  RETURN NEW;
END;
$function$
"
public,notify_on_reaction_insert_fn,,trigger,false,"CREATE OR REPLACE FUNCTION public.notify_on_reaction_insert_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  v_post_author uuid;
begin
  select p.author_id into v_post_author
  from public.posts p
  where p.id = new.post_id;

  if v_post_author is null then
    return new;
  end if;

  -- לא שולחים התראה לעצמך
  if v_post_author = new.voter_id then
    return new;
  end if;

  -- בריאקשן: כן הגיוני ""אחד לכל פוסט לכל משתמש"" => entity_id = post_id
  perform public.insert_notification(
    v_post_author,
    new.voter_id,
    'reaction',
    'post',
    new.post_id,
    jsonb_build_object(
      'post_id', new.post_id,
      'reaction_key', new.reaction_key
    )
  );

  return new;
end;
$function$
"
public,notify_on_reaction_update,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_on_reaction_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_post_author uuid;
  v_post_slug text;
  v_payload jsonb;
begin
  -- אם לא באמת השתנה הריאקשן - אין מה לעשות
  if new.reaction_key is not distinct from old.reaction_key then
    return new;
  end if;

  select p.author_id, p.slug
    into v_post_author, v_post_slug
  from public.posts p
  where p.id = new.post_id;

  if v_post_author is null then
    return new;
  end if;

  if new.voter_id = v_post_author then
    return new;
  end if;

  v_payload :=
    jsonb_build_object(
      'post_id', new.post_id,
      'post_slug', v_post_slug,
      'reaction_key', new.reaction_key
    )
    || coalesce(public.actor_snapshot(new.voter_id), '{}'::jsonb);

  perform public.insert_notification_upsert(
    v_post_author,
    new.voter_id,
    'reaction',
    'post',
    new.post_id,
    v_payload
  );

  return new;
end;
$function$
"
public,notify_post_reaction,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_post_reaction()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  row_json jsonb;
  actor uuid;
  post_id uuid;
  post_author uuid;
begin
  perform set_config('row_security', 'off', true);

  if tg_op = 'DELETE' then
    row_json := to_jsonb(old);
  else
    row_json := to_jsonb(new);
  end if;

  actor :=
    coalesce(
      nullif(row_json->>'user_id','')::uuid,
      nullif(row_json->>'profile_id','')::uuid,
      nullif(row_json->>'author_id','')::uuid,
      nullif(row_json->>'reactor_id','')::uuid
    );

  post_id :=
    coalesce(
      nullif(row_json->>'post_id','')::uuid,
      nullif(row_json->>'entity_id','')::uuid
    );

  if actor is null or post_id is null then
    if tg_op = 'DELETE' then return old; else return new; end if;
  end if;

  select p.author_id into post_author
  from public.posts p
  where p.id = post_id;

  if post_author is null then
    if tg_op = 'DELETE' then return old; else return new; end if;
  end if;

  if post_author = actor then
    if tg_op = 'DELETE' then return old; else return new; end if;
  end if;

  if tg_op = 'INSERT' or tg_op = 'UPDATE' then
    insert into public.notifications (user_id, type, actor_id, entity_id)
    values (post_author, 'reaction', actor, post_id)
    on conflict on constraint notifications_unique_event do nothing;
  end if;

  if tg_op = 'DELETE' then
    delete from public.notifications n
    where n.user_id = post_author
      and n.type = 'reaction'
      and n.actor_id = actor
      and n.entity_id = post_id;
  end if;

  if tg_op = 'DELETE' then return old; else return new; end if;
end;
$function$
"
public,notify_reaction_delete,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_reaction_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  post_author uuid;
  remaining int;
begin
  select p.author_id
    into post_author
  from public.posts p
  where p.id = old.post_id;

  if post_author is null then
    return old;
  end if;

  -- if the same actor still has reactions on this post -> keep notification
  select count(*) into remaining
  from public.post_reaction_votes v
  where v.post_id = old.post_id
    and v.voter_id = old.voter_id;

  if remaining = 0 then
    delete from public.notifications n
    where n.user_id   = post_author
      and n.actor_id  = old.voter_id
      and n.type      = 'reaction'
      and n.entity_type = 'post'
      and n.entity_id = old.post_id;
  end if;

  return old;
end;
$function$
"
public,notify_reaction_insert,,trigger,true,"CREATE OR REPLACE FUNCTION public.notify_reaction_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  post_author uuid;
  post_title text;
  post_slug text;
  actor_username text;
  actor_display_name text;
begin
  select p.author_id, p.title, p.slug
    into post_author, post_title, post_slug
  from public.posts p
  where p.id = new.post_id;

  if post_author is null then
    return new;
  end if;

  select pr.username,
         coalesce(nullif(trim(pr.display_name), ''), pr.username)
    into actor_username, actor_display_name
  from public.profiles pr
  where pr.id = new.voter_id;

  perform public._upsert_notification(
    post_author,
    new.voter_id,
    'reaction',
    'post',
    new.post_id,
    jsonb_build_object(
      'actor_username', actor_username,
      'actor_display_name', actor_display_name,
      'post_id', new.post_id,
      'post_slug', post_slug,
      'post_title', post_title,
      'reaction_key', new.reaction_key
    )
  );

  return new;
end;
$function$
"
public,pendemic_hot_posts_smart_by_channel,"p_channel_id integer, p_ref_ts timestamp with time zone, p_limit integer","TABLE(post_id uuid, reactions_total integer, window_label text)",false,"CREATE OR REPLACE FUNCTION public.pendemic_hot_posts_smart_by_channel(p_channel_id integer, p_ref_ts timestamp with time zone DEFAULT now(), p_limit integer DEFAULT 5)
 RETURNS TABLE(post_id uuid, reactions_total integer, window_label text)
 LANGUAGE sql
 STABLE
AS $function$
  with
  wb as (
    select * from public.pendemic_week_bounds(p_ref_ts) as b(ws, we)
  ),
  mb as (
    select * from public.pendemic_month_bounds(p_ref_ts) as b(ws, we)
  ),

  weekly as (
    select
      p.id as post_id,
      count(prv.*)::int as reactions_total
    from public.posts p
    join public.post_reaction_votes prv
      on prv.post_id = p.id
    cross join wb
    where
      p.channel_id = p_channel_id
      and p.published_at is not null
      and prv.created_at >= wb.ws
      and prv.created_at <  wb.we
    group by p.id
    order by reactions_total desc, p.published_at desc nulls last
    limit p_limit
  ),

  weekly_ids as (select post_id from weekly),

  monthly_fill as (
    select
      p.id as post_id,
      count(prv.*)::int as reactions_total
    from public.posts p
    join public.post_reaction_votes prv
      on prv.post_id = p.id
    cross join mb
    where
      p.channel_id = p_channel_id
      and p.published_at is not null
      and prv.created_at >= mb.ws
      and prv.created_at <  mb.we
      and not exists (select 1 from weekly_ids w where w.post_id = p.id)
    group by p.id
    order by reactions_total desc, p.published_at desc nulls last
    limit greatest(p_limit - (select count(*) from weekly), 0)
  ),

  hot_ids as (
    select post_id from weekly
    union
    select post_id from monthly_fill
  ),

  recent_fill as (
    select
      p.id as post_id,
      0::int as reactions_total
    from public.posts p
    where
      p.channel_id = p_channel_id
      and p.published_at is not null
      and not exists (select 1 from hot_ids h where h.post_id = p.id)
    order by p.published_at desc nulls last
    limit greatest(
      p_limit - ((select count(*) from weekly) + (select count(*) from monthly_fill)),
      0
    )
  )

  select post_id, reactions_total, 'week'::text as window_label
  from weekly

  union all

  select post_id, reactions_total, 'month'::text as window_label
  from monthly_fill

  union all

  select post_id, reactions_total, 'recent'::text as window_label
  from recent_fill;
$function$
"
public,pendemic_hot_posts_weekly_by_channel,"p_channel_id integer, p_ref_ts timestamp with time zone, p_limit integer","TABLE(post_id uuid, reactions_total integer)",false,"CREATE OR REPLACE FUNCTION public.pendemic_hot_posts_weekly_by_channel(p_channel_id integer, p_ref_ts timestamp with time zone DEFAULT now(), p_limit integer DEFAULT 5)
 RETURNS TABLE(post_id uuid, reactions_total integer)
 LANGUAGE sql
 STABLE
AS $function$
  with b as (
    select * 
    from public.pendemic_week_bounds(p_ref_ts) as wb(ws, we)
  )
  select
    p.id as post_id,
    count(prv.*)::int as reactions_total
  from public.posts p
  join public.post_reaction_votes prv
    on prv.post_id = p.id
  cross join b
  where
    p.channel_id = p_channel_id
    and p.published_at is not null   -- ← זה התיקון
    and prv.created_at >= b.ws
    and prv.created_at <  b.we
  group by p.id
  order by reactions_total desc, p.published_at desc nulls last
  limit p_limit;
$function$
"
public,pendemic_hot_posts_weekly_with_fallback_by_channel,"p_channel_id integer, p_ref_ts timestamp with time zone, p_limit integer","TABLE(post_id uuid, reactions_total integer, window_label text)",false,"CREATE OR REPLACE FUNCTION public.pendemic_hot_posts_weekly_with_fallback_by_channel(p_channel_id integer, p_ref_ts timestamp with time zone DEFAULT now(), p_limit integer DEFAULT 5)
 RETURNS TABLE(post_id uuid, reactions_total integer, window_label text)
 LANGUAGE sql
 STABLE
AS $function$
  with
  wb as (
    select * from public.pendemic_week_bounds(p_ref_ts) as b(ws, we)
  ),
  mb as (
    select * from public.pendemic_month_bounds(p_ref_ts) as b(ws, we)
  ),

  weekly as (
    select
      p.id as post_id,
      count(prv.*)::int as reactions_total
    from public.posts p
    join public.post_reaction_votes prv
      on prv.post_id = p.id
    cross join wb
    where
      p.channel_id = p_channel_id
      and p.published_at is not null
      and prv.created_at >= wb.ws
      and prv.created_at <  wb.we
    group by p.id
    order by reactions_total desc, p.published_at desc nulls last
    limit p_limit
  ),

  weekly_ids as (
    select post_id from weekly
  ),

  monthly_fill as (
    select
      p.id as post_id,
      count(prv.*)::int as reactions_total
    from public.posts p
    join public.post_reaction_votes prv
      on prv.post_id = p.id
    cross join mb
    where
      p.channel_id = p_channel_id
      and p.published_at is not null
      and prv.created_at >= mb.ws
      and prv.created_at <  mb.we
      and not exists (select 1 from weekly_ids w where w.post_id = p.id)
    group by p.id
    order by reactions_total desc, p.published_at desc nulls last
    limit greatest(p_limit - (select count(*) from weekly), 0)
  )

  select post_id, reactions_total, 'week'::text as window_label
  from weekly

  union all

  select post_id, reactions_total, 'month'::text as window_label
  from monthly_fill;
$function$
"
public,pendemic_medals_reset4,v_votes integer,"TABLE(gold integer, silver integer, bronze integer)",false,"CREATE OR REPLACE FUNCTION public.pendemic_medals_reset4(v_votes integer)
 RETURNS TABLE(gold integer, silver integer, bronze integer)
 LANGUAGE sql
 STABLE
AS $function$
  with vv as (
    select greatest(coalesce(v_votes,0),0)::int as votes
  ),
  bt as (
    select floor(votes/4.0)::int as b_total from vv
  ),
  st as (
    select b_total, floor(b_total/4.0)::int as s_total from bt
  ),
  gt as (
    select b_total, s_total, floor(s_total/4.0)::int as g_total from st
  )
  select
    greatest(g_total,0) as gold,
    greatest(s_total - (g_total * 4),0) as silver,
    greatest(b_total - (s_total * 4),0) as bronze
  from gt;
$function$
"
public,pendemic_medals_reset4_post_display,v_votes integer,"TABLE(gold integer, silver integer, bronze integer)",false,"CREATE OR REPLACE FUNCTION public.pendemic_medals_reset4_post_display(v_votes integer)
 RETURNS TABLE(gold integer, silver integer, bronze integer)
 LANGUAGE sql
 STABLE
AS $function$
  with m as (
    select * from public.pendemic_medals_reset4(v_votes)
  )
  select
    least(m.gold, 6) as gold,
    m.silver as silver,
    m.bronze as bronze
  from m;
$function$
"
public,pendemic_month_bounds,ref_ts timestamp with time zone,"TABLE(start_ts timestamp with time zone, end_ts timestamp with time zone)",false,"CREATE OR REPLACE FUNCTION public.pendemic_month_bounds(ref_ts timestamp with time zone DEFAULT now())
 RETURNS TABLE(start_ts timestamp with time zone, end_ts timestamp with time zone)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
  tz text := 'Asia/Jerusalem';
  local_ts timestamp := (ref_ts at time zone tz);
  month_start_local timestamp := date_trunc('month', local_ts);
  month_end_local timestamp := (date_trunc('month', local_ts) + interval '1 month');
begin
  start_ts := month_start_local at time zone tz;
  end_ts := month_end_local at time zone tz;
  return next;
end;
$function$
"
public,pendemic_ranked_posts_monthly,"ref_ts timestamp with time zone, channel_slugs text[], limit_count integer","TABLE(post_id uuid, reactions_total integer, comments_total integer, reactions_by_key jsonb, gold integer, silver integer, bronze integer, window_start timestamp with time zone, window_end timestamp with time zone)",false,"CREATE OR REPLACE FUNCTION public.pendemic_ranked_posts_monthly(ref_ts timestamp with time zone DEFAULT now(), channel_slugs text[] DEFAULT NULL::text[], limit_count integer DEFAULT 50)
 RETURNS TABLE(post_id uuid, reactions_total integer, comments_total integer, reactions_by_key jsonb, gold integer, silver integer, bronze integer, window_start timestamp with time zone, window_end timestamp with time zone)
 LANGUAGE sql
 STABLE
AS $function$
  with bounds as (
    select b.ws as window_start, b.we as window_end
    from public.pendemic_month_bounds(ref_ts) as b(ws, we)
  ),
  filtered_posts as (
    select p.id as pid
    from public.posts p
    left join public.channels c on c.id = p.channel_id
    where p.deleted_at is null
      and p.status = 'published'
      and (channel_slugs is null or c.slug = any(channel_slugs))
  ),
  votes_by_key as (
    select v.post_id as pid, v.reaction_key, count(*)::int as cnt
    from public.post_reaction_votes v
    cross join bounds b
    where v.created_at >= b.window_start
      and v.created_at <  b.window_end
    group by v.post_id, v.reaction_key
  ),
  votes as (
    select
      vbk.pid,
      sum(vbk.cnt)::int as reactions_total,
      jsonb_object_agg(vbk.reaction_key, vbk.cnt) as reactions_by_key
    from votes_by_key vbk
    group by vbk.pid
  ),
  comments as (
    select c.post_id as pid, count(*)::int as comments_total
    from public.comments c
    cross join bounds b
    where c.created_at >= b.window_start
      and c.created_at <  b.window_end
    group by c.post_id
  )
  select
    fp.pid as post_id,
    coalesce(v.reactions_total, 0) as reactions_total,
    coalesce(cm.comments_total, 0) as comments_total,
    coalesce(v.reactions_by_key, '{}'::jsonb) as reactions_by_key,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).gold as gold,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).silver as silver,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).bronze as bronze,
    b.window_start,
    b.window_end
  from filtered_posts fp
  cross join bounds b
  left join votes v on v.pid = fp.pid
  left join comments cm on cm.pid = fp.pid
  order by coalesce(v.reactions_total,0) desc,
           coalesce(cm.comments_total,0) desc
  limit greatest(limit_count, 1);
$function$
"
public,pendemic_ranked_posts_weekly,"ref_ts timestamp with time zone, channel_slugs text[], limit_count integer","TABLE(post_id uuid, reactions_total integer, comments_total integer, reactions_by_key jsonb, gold integer, silver integer, bronze integer, window_start timestamp with time zone, window_end timestamp with time zone)",false,"CREATE OR REPLACE FUNCTION public.pendemic_ranked_posts_weekly(ref_ts timestamp with time zone DEFAULT now(), channel_slugs text[] DEFAULT NULL::text[], limit_count integer DEFAULT 50)
 RETURNS TABLE(post_id uuid, reactions_total integer, comments_total integer, reactions_by_key jsonb, gold integer, silver integer, bronze integer, window_start timestamp with time zone, window_end timestamp with time zone)
 LANGUAGE sql
 STABLE
AS $function$
  with bounds as (
    select b.ws as window_start, b.we as window_end
    from public.pendemic_week_bounds(ref_ts) as b(ws, we)
  ),
  filtered_posts as (
    select p.id as pid
    from public.posts p
    left join public.channels c on c.id = p.channel_id
    where p.deleted_at is null
      and p.status = 'published'
      and (channel_slugs is null or c.slug = any(channel_slugs))
  ),
  votes_by_key as (
    select v.post_id as pid, v.reaction_key, count(*)::int as cnt
    from public.post_reaction_votes v
    cross join bounds b
    where v.created_at >= b.window_start
      and v.created_at <  b.window_end
    group by v.post_id, v.reaction_key
  ),
  votes as (
    select
      vbk.pid,
      sum(vbk.cnt)::int as reactions_total,
      jsonb_object_agg(vbk.reaction_key, vbk.cnt) as reactions_by_key
    from votes_by_key vbk
    group by vbk.pid
  ),
  comments as (
    select c.post_id as pid, count(*)::int as comments_total
    from public.comments c
    cross join bounds b
    where c.created_at >= b.window_start
      and c.created_at <  b.window_end
    group by c.post_id
  )
  select
    fp.pid as post_id,
    coalesce(v.reactions_total, 0) as reactions_total,
    coalesce(cm.comments_total, 0) as comments_total,
    coalesce(v.reactions_by_key, '{}'::jsonb) as reactions_by_key,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).gold as gold,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).silver as silver,
    (public.pendemic_medals_reset4(coalesce(v.reactions_total,0))).bronze as bronze,
    b.window_start,
    b.window_end
  from filtered_posts fp
  cross join bounds b
  left join votes v on v.pid = fp.pid
  left join comments cm on cm.pid = fp.pid
  order by coalesce(v.reactions_total,0) desc,
           coalesce(cm.comments_total,0) desc
  limit greatest(limit_count, 1);
$function$
"
public,pendemic_week_bounds,ref_ts timestamp with time zone,"TABLE(start_ts timestamp with time zone, end_ts timestamp with time zone)",false,"CREATE OR REPLACE FUNCTION public.pendemic_week_bounds(ref_ts timestamp with time zone DEFAULT now())
 RETURNS TABLE(start_ts timestamp with time zone, end_ts timestamp with time zone)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
  tz text := 'Asia/Jerusalem';
  local_ts timestamp := (ref_ts at time zone tz);
  local_midnight timestamp := date_trunc('day', local_ts);
  dow int := extract(dow from local_ts); -- sunday=0
  week_start_local timestamp := local_midnight - make_interval(days => dow);
  week_end_local timestamp := week_start_local + interval '7 days';
begin
  start_ts := week_start_local at time zone tz;
  end_ts := week_end_local at time zone tz;
  return next;
end;
$function$
"
public,prevent_self_like_comment,,trigger,true,"CREATE OR REPLACE FUNCTION public.prevent_self_like_comment()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_comment_owner uuid;
begin
  select user_id into v_comment_owner
  from public.post_comments
  where id = new.comment_id;

  if v_comment_owner is null then
    return new;
  end if;

  if v_comment_owner = new.user_id then
    raise exception 'cannot_like_own_comment';
  end if;

  return new;
end;
$function$
"
public,prevent_self_vote,,trigger,false,"CREATE OR REPLACE FUNCTION public.prevent_self_vote()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  author uuid;
begin
  select author_id into author from public.posts where id = new.post_id;

  if author = new.voter_id then
    raise exception 'Cannot vote on your own post';
  end if;

  return new;
end;
$function$
"
public,purge_post,p_post_id uuid,void,true,"CREATE OR REPLACE FUNCTION public.purge_post(p_post_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_author uuid;
begin
  select author_id into v_author
  from public.posts
  where id = p_post_id;

  if v_author is null then
    raise exception 'post not found';
  end if;

  if v_author <> auth.uid() then
    raise exception 'not allowed';
  end if;

  -- delete children first (avoid FK issues)
  delete from public.post_tags where post_id = p_post_id;
  delete from public.comments where post_id = p_post_id;
  delete from public.post_reaction_votes where post_id = p_post_id;
  delete from public.post_votes where post_id = p_post_id;
  delete from public.moderation_actions where post_id = p_post_id;

  -- notifications uses entity_type/entity_id
  delete from public.notifications
  where entity_type = 'post' and entity_id = p_post_id;

  delete from public.posts where id = p_post_id;
end;
$function$
"
public,purge_soft_deleted_posts,,void,true,"CREATE OR REPLACE FUNCTION public.purge_soft_deleted_posts()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  cutoff timestamptz := now() - interval '14 days';
begin
  delete from public.notifications
  where entity_type = 'post'
    and entity_id in (
      select id from public.posts
      where deleted_at is not null and deleted_at < cutoff
    );

  delete from public.post_reaction_votes
  where post_id in (
    select id from public.posts
    where deleted_at is not null and deleted_at < cutoff
  );

  delete from public.post_tags
  where post_id in (
    select id from public.posts
    where deleted_at is not null and deleted_at < cutoff
  );

  delete from public.comments
  where post_id in (
    select id from public.posts
    where deleted_at is not null and deleted_at < cutoff
  );

  delete from public.moderation_actions
  where post_id in (
    select id from public.posts
    where deleted_at is not null and deleted_at < cutoff
  );

  delete from public.posts
  where deleted_at is not null and deleted_at < cutoff;
end;
$function$
"
public,search_posts_v1,"p_query text, p_channel_id smallint, p_tag_id integer, p_sort text, p_limit integer, p_offset integer","TABLE(id uuid, author_id uuid, title text, slug text, excerpt text, status text, published_at timestamp with time zone, created_at timestamp with time zone, updated_at timestamp with time zone, channel_id smallint, subcategory_tag_id integer, cover_image_url text, is_anonymous boolean, comments_count bigint, reactions_count bigint, author_username text, author_display_name text, author_avatar_url text)",false,"CREATE OR REPLACE FUNCTION public.search_posts_v1(p_query text DEFAULT NULL::text, p_channel_id smallint DEFAULT NULL::smallint, p_tag_id integer DEFAULT NULL::integer, p_sort text DEFAULT 'new'::text, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0)
 RETURNS TABLE(id uuid, author_id uuid, title text, slug text, excerpt text, status text, published_at timestamp with time zone, created_at timestamp with time zone, updated_at timestamp with time zone, channel_id smallint, subcategory_tag_id integer, cover_image_url text, is_anonymous boolean, comments_count bigint, reactions_count bigint, author_username text, author_display_name text, author_avatar_url text)
 LANGUAGE sql
 STABLE
AS $function$
  select
    pwc.id,
    pwc.author_id,
    pwc.title,
    pwc.slug,
    pwc.excerpt,
    pwc.status,
    pwc.published_at,
    pwc.created_at,
    pwc.updated_at,
    pwc.channel_id,
    pwc.subcategory_tag_id,
    pwc.cover_image_url,
    pwc.is_anonymous,
    pwc.comments_count,
    pwc.reactions_count,
    pr.username as author_username,
    pr.display_name as author_display_name,
    pr.avatar_url as author_avatar_url
  from public.posts_with_counts pwc
  join public.profiles pr on pr.id = pwc.author_id
  where
    -- keep published only (aligns with typical public feed expectations)
    pwc.status = 'published'
    and pwc.published_at is not null
    and pwc.published_at <= now()
    and (p_channel_id is null or pwc.channel_id = p_channel_id)
    and (
      p_tag_id is null
      or pwc.subcategory_tag_id = p_tag_id
      or exists (
        select 1
        from public.post_tags pt
        where pt.post_id = pwc.id
          and pt.tag_id = p_tag_id
      )
    )
    and (
      p_query is null
      or pwc.title ilike ('%' || p_query || '%')
      or (pwc.excerpt is not null and pwc.excerpt ilike ('%' || p_query || '%'))
    )
  order by
    case when p_sort = 'comments' then pwc.comments_count end desc nulls last,
    case when p_sort = 'reactions' then pwc.reactions_count end desc nulls last,
    -- default / tie-breaker
    coalesce(pwc.published_at, pwc.created_at) desc
  limit greatest(1, least(p_limit, 50))
  offset greatest(p_offset, 0);
$function$
"
public,send_message,"p_conversation_id uuid, p_body text",uuid,true,"CREATE OR REPLACE FUNCTION public.send_message(p_conversation_id uuid, p_body text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  me uuid;
  mid uuid;
begin
  me := auth.uid();
  if me is null then
    raise exception 'not authenticated';
  end if;

  if p_conversation_id is null then
    raise exception 'conversation_id is null';
  end if;

  if p_body is null or length(trim(p_body)) = 0 then
    raise exception 'empty body';
  end if;

  if not exists (
    select 1
    from public.conversation_members m
    where m.conversation_id = p_conversation_id
      and m.user_id = me
  ) then
    raise exception 'not a member of this conversation';
  end if;

  insert into public.messages (conversation_id, sender_id, body)
  values (p_conversation_id, me, trim(p_body))
  returning id into mid;

  return mid;
end;
$function$
"
public,set_message_sender,,trigger,false,"CREATE OR REPLACE FUNCTION public.set_message_sender()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  if new.sender_id is null then
    new.sender_id := auth.uid();
  end if;

  return new;
end;
$function$
"
public,set_updated_at,,trigger,false,"CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end;
$function$
"
public,start_conversation,other_user_id uuid,uuid,true,"CREATE OR REPLACE FUNCTION public.start_conversation(other_user_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  me uuid := auth.uid();
  conv_id uuid;
begin
  if me is null then
    raise exception 'Not authenticated';
  end if;

  if other_user_id is null or other_user_id = me then
    raise exception 'Invalid user';
  end if;

  -- find existing 1:1 conversation that has exactly these two members
  select m1.conversation_id into conv_id
  from public.conversation_members m1
  join public.conversation_members m2
    on m2.conversation_id = m1.conversation_id
  where m1.user_id = me
    and m2.user_id = other_user_id
  group by m1.conversation_id
  having count(*) = 1;

  if conv_id is not null then
    -- ensure it's only 2 members (true 1:1)
    if (select count(*) from public.conversation_members where conversation_id = conv_id) = 2 then
      return conv_id;
    end if;
  end if;

  -- create new conversation
  insert into public.conversations default values returning id into conv_id;

  insert into public.conversation_members (conversation_id, user_id, last_read_at)
  values
    (conv_id, me, now()),
    (conv_id, other_user_id, null);

  return conv_id;
end;
$function$
"
public,trg_notify_follow_delete,,trigger,true,"CREATE OR REPLACE FUNCTION public.trg_notify_follow_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  perform set_config('row_security', 'off', true);

  delete from public.notifications n
  where n.user_id = old.following_id
    and n.type = 'follow'
    and n.actor_id = old.follower_id
    and n.entity_id = old.follower_id;

  return old;
end;
$function$
"
public,trg_notify_follow_delete_fn,,trigger,true,"CREATE OR REPLACE FUNCTION public.trg_notify_follow_delete_fn()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  actor_username text;
  actor_display text;
begin
  if old.follower_id = old.following_id then
    return old;
  end if;

  select p.username,
         coalesce(nullif(trim(p.display_name), ''), p.username, 'מישהו')
    into actor_username, actor_display
  from public.profiles p
  where p.id = old.follower_id;

  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read
  )
  values (
    old.following_id,
    old.follower_id,
    'unfollow',
    'profile',
    old.follower_id,
    jsonb_build_object(
      'actor_username', actor_username,
      'actor_display_name', actor_display
    ),
    false
  )
  on conflict (user_id, type, actor_id, entity_id) do nothing;

  return old;
end;
$function$
"
public,trg_notify_follow_insert,,trigger,true,"CREATE OR REPLACE FUNCTION public.trg_notify_follow_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  actor_name text;
  actor_username text;
begin
  -- לא שולחים לעצמך
  if new.follower_id = new.following_id then
    return new;
  end if;

  -- מכבים RLS בתוך ההקשר הזה בלבד (כדי שהטריגר תמיד יוכל להכניס notifications)
  perform set_config('row_security', 'off', true);

  select
    coalesce(nullif(trim(p.display_name), ''), p.username),
    p.username
  into actor_name, actor_username
  from public.profiles p
  where p.id = new.follower_id;

  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read
  )
  values (
    new.following_id,
    new.follower_id,
    'follow',
    'profile',
    new.follower_id, -- חשוב: זה מונע כפילויות מאותו עוקב בגלל ה-unique שלך
    jsonb_build_object(
      'actor_display_name', actor_name,
      'actor_username', actor_username
    ),
    false
  )
  on conflict on constraint notifications_unique_event
  do nothing;

  return new;
end;
$function$
"
public,trg_notify_follow_insert_fn,,trigger,true,"CREATE OR REPLACE FUNCTION public.trg_notify_follow_insert_fn()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  actor_username text;
  actor_display text;
begin
  -- לא שולחים התראה לעצמך
  if new.follower_id = new.following_id then
    return new;
  end if;

  select p.username,
         coalesce(nullif(trim(p.display_name), ''), p.username, 'מישהו')
    into actor_username, actor_display
  from public.profiles p
  where p.id = new.follower_id;

  insert into public.notifications (
    user_id,
    actor_id,
    type,
    entity_type,
    entity_id,
    payload,
    is_read
  )
  values (
    new.following_id,              -- מי שמקבל
    new.follower_id,               -- מי שעשה
    'follow',
    'profile',
    new.follower_id,               -- entity_id = השחקן (או אפשר following_id, אבל אז זה משפיע על unique)
    jsonb_build_object(
      'actor_username', actor_username,
      'actor_display_name', actor_display
    ),
    false
  )
  on conflict (user_id, type, actor_id, entity_id) do nothing;

  return new;
end;
$function$
"
public,upsert_community_note,body text,community_notes,true,"CREATE OR REPLACE FUNCTION public.upsert_community_note(body text)
 RETURNS community_notes
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user uuid := auth.uid();
  v_last timestamptz;
  v_note public.community_notes;
  v_remaining interval;
begin
  if v_user is null then
    raise exception 'not_authenticated';
  end if;

  if body is null or char_length(trim(body)) < 1 then
    raise exception 'empty_body';
  end if;

  if char_length(body) > 220 then
    raise exception 'body_too_long';
  end if;

  select updated_at into v_last
  from public.community_notes
  where user_id = v_user;

  if v_last is not null and now() - v_last < interval '10 minutes' then
    v_remaining := interval '10 minutes' - (now() - v_last);
    -- Put remaining seconds in ""detail"" so the client can show a countdown
    raise exception 'cooldown'
      using detail = floor(extract(epoch from v_remaining))::text;
  end if;

  insert into public.community_notes(user_id, body, created_at, updated_at)
  values (v_user, trim(body), now(), now())
  on conflict (user_id)
  do update set body = excluded.body, updated_at = now()
  returning * into v_note;

  return v_note;
end;
$function$
"
public,upsert_notification,"p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb",void,true,"CREATE OR REPLACE FUNCTION public.upsert_notification(p_user_id uuid, p_actor_id uuid, p_type text, p_entity_type text, p_entity_id uuid, p_payload jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_payload jsonb := p_payload;
  v_from_user_name text;
  v_from_user_avatar_url text;
BEGIN
  -- enrich payload with actor profile data (name + avatar)
  IF p_actor_id IS NOT NULL THEN
    SELECT
      COALESCE(NULLIF(pr.display_name, ''), pr.username),
      pr.avatar_url
    INTO
      v_from_user_name,
      v_from_user_avatar_url
    FROM public.profiles pr
    WHERE pr.id = p_actor_id;

    -- write/overwrite only if missing or empty (no ""duplication"", just updates the key)
    IF v_from_user_name IS NOT NULL
       AND (v_payload->>'from_user_name' IS NULL OR v_payload->>'from_user_name' = '') THEN
      v_payload := v_payload || jsonb_build_object('from_user_name', v_from_user_name);
    END IF;

    IF v_from_user_avatar_url IS NOT NULL
       AND (v_payload->>'from_user_avatar_url' IS NULL OR v_payload->>'from_user_avatar_url' = '') THEN
      v_payload := v_payload || jsonb_build_object('from_user_avatar_url', v_from_user_avatar_url);
    END IF;
  END IF;

  INSERT INTO public.notifications(user_id, actor_id, type, entity_type, entity_id, payload, is_read, created_at, read_at)
  VALUES (p_user_id, p_actor_id, p_type, p_entity_type, p_entity_id, v_payload, false, now(), null)
  ON CONFLICT (user_id, type, actor_id, entity_id)
  DO UPDATE SET
    payload    = excluded.payload,
    is_read    = false,
    created_at = now(),
    read_at    = null;
END;
$function$
"
realtime,apply_rls,"wal jsonb, max_record_bytes integer",SETOF realtime.wal_rls,false,"CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))
 RETURNS SETOF realtime.wal_rls
 LANGUAGE plpgsql
AS $function$
declare
-- Regclass of the table e.g. public.notes
entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;

-- I, U, D, T: insert, update ...
action realtime.action = (
    case wal ->> 'action'
        when 'I' then 'INSERT'
        when 'U' then 'UPDATE'
        when 'D' then 'DELETE'
        else 'ERROR'
    end
);

-- Is row level security enabled for the table
is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;

subscriptions realtime.subscription[] = array_agg(subs)
    from
        realtime.subscription subs
    where
        subs.entity = entity_
        -- Filter by action early - only get subscriptions interested in this action
        -- action_filter column can be: '*' (all), 'INSERT', 'UPDATE', or 'DELETE'
        and (subs.action_filter = '*' or subs.action_filter = action::text);

-- Subscription vars
roles regrole[] = array_agg(distinct us.claims_role::text)
    from
        unnest(subscriptions) us;

working_role regrole;
claimed_role regrole;
claims jsonb;

subscription_id uuid;
subscription_has_access bool;
visible_to_subscription_ids uuid[] = '{}';

-- structured info for wal's columns
columns realtime.wal_column[];
-- previous identity values for update/delete
old_columns realtime.wal_column[];

error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;

-- Primary jsonb output for record
output jsonb;

begin
perform set_config('role', null, true);

columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'columns') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

old_columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'identity') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

for working_role in select * from unnest(roles) loop

    -- Update `is_selectable` for columns and old_columns
    columns =
        array_agg(
            (
                c.name,
                c.type_name,
                c.type_oid,
                c.value,
                c.is_pkey,
                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
            )::realtime.wal_column
        )
        from
            unnest(columns) c;

    old_columns =
            array_agg(
                (
                    c.name,
                    c.type_name,
                    c.type_oid,
                    c.value,
                    c.is_pkey,
                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
                )::realtime.wal_column
            )
            from
                unnest(old_columns) c;

    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            -- subscriptions is already filtered by entity
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 400: Bad Request, no primary key']
        )::realtime.wal_rls;

    -- The claims role does not have SELECT permission to the primary key of entity
    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 401: Unauthorized']
        )::realtime.wal_rls;

    else
        output = jsonb_build_object(
            'schema', wal ->> 'schema',
            'table', wal ->> 'table',
            'type', action,
            'commit_timestamp', to_char(
                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),
                'YYYY-MM-DD""T""HH24:MI:SS.MS""Z""'
            ),
            'columns', (
                select
                    jsonb_agg(
                        jsonb_build_object(
                            'name', pa.attname,
                            'type', pt.typname
                        )
                        order by pa.attnum asc
                    )
                from
                    pg_attribute pa
                    join pg_type pt
                        on pa.atttypid = pt.oid
                where
                    attrelid = entity_
                    and attnum > 0
                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')
            )
        )
        -- Add ""record"" key for insert and update
        || case
            when action in ('INSERT', 'UPDATE') then
                jsonb_build_object(
                    'record',
                    (
                        select
                            jsonb_object_agg(
                                -- if unchanged toast, get column name and value from old record
                                coalesce((c).name, (oc).name),
                                case
                                    when (c).name is null then (oc).value
                                    else (c).value
                                end
                            )
                        from
                            unnest(columns) c
                            full outer join unnest(old_columns) oc
                                on (c).name = (oc).name
                        where
                            coalesce((c).is_selectable, (oc).is_selectable)
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                    )
                )
            else '{}'::jsonb
        end
        -- Add ""old_record"" key for update and delete
        || case
            when action = 'UPDATE' then
                jsonb_build_object(
                        'old_record',
                        (
                            select jsonb_object_agg((c).name, (c).value)
                            from unnest(old_columns) c
                            where
                                (c).is_selectable
                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                        )
                    )
            when action = 'DELETE' then
                jsonb_build_object(
                    'old_record',
                    (
                        select jsonb_object_agg((c).name, (c).value)
                        from unnest(old_columns) c
                        where
                            (c).is_selectable
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey
                    )
                )
            else '{}'::jsonb
        end;

        -- Create the prepared statement
        if is_rls_enabled and action <> 'DELETE' then
            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then
                deallocate walrus_rls_stmt;
            end if;
            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);
        end if;

        visible_to_subscription_ids = '{}';

        for subscription_id, claims in (
                select
                    subs.subscription_id,
                    subs.claims
                from
                    unnest(subscriptions) subs
                where
                    subs.entity = entity_
                    and subs.claims_role = working_role
                    and (
                        realtime.is_visible_through_filters(columns, subs.filters)
                        or (
                          action = 'DELETE'
                          and realtime.is_visible_through_filters(old_columns, subs.filters)
                        )
                    )
        ) loop

            if not is_rls_enabled or action = 'DELETE' then
                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
            else
                -- Check if RLS allows the role to see the record
                perform
                    -- Trim leading and trailing quotes from working_role because set_config
                    -- doesn't recognize the role as valid if they are included
                    set_config('role', trim(both '""' from working_role::text), true),
                    set_config('request.jwt.claims', claims::text, true);

                execute 'execute walrus_rls_stmt' into subscription_has_access;

                if subscription_has_access then
                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
                end if;
            end if;
        end loop;

        perform set_config('role', null, true);

        return next (
            output,
            is_rls_enabled,
            visible_to_subscription_ids,
            case
                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']
                else '{}'
            end
        )::realtime.wal_rls;

    end if;
end loop;

perform set_config('role', null, true);
end;
$function$
"
realtime,broadcast_changes,"topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text",void,false,"CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    -- Declare a variable to hold the JSONB representation of the row
    row_data jsonb := '{}'::jsonb;
BEGIN
    IF level = 'STATEMENT' THEN
        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';
    END IF;
    -- Check the operation type and handle accordingly
    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN
        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);
        PERFORM realtime.send (row_data, event_name, topic_name);
    ELSE
        RAISE EXCEPTION 'Unexpected operation type: %', operation;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;
END;

$function$
"
realtime,build_prepared_statement_sql,"prepared_statement_name text, entity regclass, columns realtime.wal_column[]",text,false,"CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])
 RETURNS text
 LANGUAGE sql
AS $function$
      /*
      Builds a sql string that, if executed, creates a prepared statement to
      tests retrive a row from *entity* by its primary key columns.
      Example
          select realtime.build_prepared_statement_sql('public.notes', '{""id""}'::text[], '{""bigint""}'::text[])
      */
          select
      'prepare ' || prepared_statement_name || ' as
          select
              exists(
                  select
                      1
                  from
                      ' || entity || '
                  where
                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '
              )'
          from
              unnest(columns) pkc
          where
              pkc.is_pkey
          group by
              entity
      $function$
"
realtime,cast,"val text, type_ regtype",jsonb,false,"CREATE OR REPLACE FUNCTION realtime.""cast""(val text, type_ regtype)
 RETURNS jsonb
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
    declare
      res jsonb;
    begin
      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;
      return res;
    end
    $function$
"
realtime,check_equality_op,"op realtime.equality_op, type_ regtype, val_1 text, val_2 text",boolean,false,"CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)
 RETURNS boolean
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
      /*
      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness
      */
      declare
          op_symbol text = (
              case
                  when op = 'eq' then '='
                  when op = 'neq' then '!='
                  when op = 'lt' then '<'
                  when op = 'lte' then '<='
                  when op = 'gt' then '>'
                  when op = 'gte' then '>='
                  when op = 'in' then '= any'
                  else 'UNKNOWN OP'
              end
          );
          res boolean;
      begin
          execute format(
              'select %L::'|| type_::text || ' ' || op_symbol
              || ' ( %L::'
              || (
                  case
                      when op = 'in' then type_::text || '[]'
                      else type_::text end
              )
              || ')', val_1, val_2) into res;
          return res;
      end;
      $function$
"
realtime,is_visible_through_filters,"columns realtime.wal_column[], filters realtime.user_defined_filter[]",boolean,false,"CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])
 RETURNS boolean
 LANGUAGE sql
 IMMUTABLE
AS $function$
    /*
    Should the record be visible (true) or filtered out (false) after *filters* are applied
    */
        select
            -- Default to allowed when no filters present
            $2 is null -- no filters. this should not happen because subscriptions has a default
            or array_length($2, 1) is null -- array length of an empty array is null
            or bool_and(
                coalesce(
                    realtime.check_equality_op(
                        op:=f.op,
                        type_:=coalesce(
                            col.type_oid::regtype, -- null when wal2json version <= 2.4
                            col.type_name::regtype
                        ),
                        -- cast jsonb to text
                        val_1:=col.value #>> '{}',
                        val_2:=f.value
                    ),
                    false -- if null, filter does not match
                )
            )
        from
            unnest(filters) f
            join unnest(columns) col
                on f.column_name = col.name;
    $function$
"
realtime,list_changes,"publication name, slot_name name, max_changes integer, max_record_bytes integer",SETOF realtime.wal_rls,false,"CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)
 RETURNS SETOF realtime.wal_rls
 LANGUAGE sql
 SET log_min_messages TO 'fatal'
AS $function$
      with pub as (
        select
          concat_ws(
            ',',
            case when bool_or(pubinsert) then 'insert' else null end,
            case when bool_or(pubupdate) then 'update' else null end,
            case when bool_or(pubdelete) then 'delete' else null end
          ) as w2j_actions,
          coalesce(
            string_agg(
              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),
              ','
            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),
            ''
          ) w2j_add_tables
        from
          pg_publication pp
          left join pg_publication_tables ppt
            on pp.pubname = ppt.pubname
        where
          pp.pubname = publication
        group by
          pp.pubname
        limit 1
      ),
      w2j as (
        select
          x.*, pub.w2j_add_tables
        from
          pub,
          pg_logical_slot_get_changes(
            slot_name, null, max_changes,
            'include-pk', 'true',
            'include-transaction', 'false',
            'include-timestamp', 'true',
            'include-type-oids', 'true',
            'format-version', '2',
            'actions', pub.w2j_actions,
            'add-tables', pub.w2j_add_tables
          ) x
      )
      select
        xyz.wal,
        xyz.is_rls_enabled,
        xyz.subscription_ids,
        xyz.errors
      from
        w2j,
        realtime.apply_rls(
          wal := w2j.data::jsonb,
          max_record_bytes := max_record_bytes
        ) xyz(wal, is_rls_enabled, subscription_ids, errors)
      where
        w2j.w2j_add_tables <> ''
        and xyz.subscription_ids[1] is not null
    $function$
"
realtime,quote_wal2json,entity regclass,text,false,"CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
      select
        (
          select string_agg('' || ch,'')
          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '""')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '""'
            )
        )
        || '.'
        || (
          select string_agg('' || ch,'')
          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '""')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '""'
            )
          )
      from
        pg_class pc
        join pg_namespace nsp
          on pc.relnamespace = nsp.oid
      where
        pc.oid = entity
    $function$
"
realtime,send,"payload jsonb, event text, topic text, private boolean",void,false,"CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  generated_id uuid;
  final_payload jsonb;
BEGIN
  BEGIN
    -- Generate a new UUID for the id
    generated_id := gen_random_uuid();

    -- Check if payload has an 'id' key, if not, add the generated UUID
    IF payload ? 'id' THEN
      final_payload := payload;
    ELSE
      final_payload := jsonb_set(payload, '{id}', to_jsonb(generated_id));
    END IF;

    -- Set the topic configuration
    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);

    -- Attempt to insert the message
    INSERT INTO realtime.messages (id, payload, event, topic, private, extension)
    VALUES (generated_id, final_payload, event, topic, private, 'broadcast');
  EXCEPTION
    WHEN OTHERS THEN
      -- Capture and notify the error
      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;
  END;
END;
$function$
"
realtime,subscription_check_filters,,trigger,false,"CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
    /*
    Validates that the user defined filters for a subscription:
    - refer to valid columns that the claimed role may access
    - values are coercable to the correct column type
    */
    declare
        col_names text[] = coalesce(
                array_agg(c.column_name order by c.ordinal_position),
                '{}'::text[]
            )
            from
                information_schema.columns c
            where
                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity
                and pg_catalog.has_column_privilege(
                    (new.claims ->> 'role'),
                    format('%I.%I', c.table_schema, c.table_name)::regclass,
                    c.column_name,
                    'SELECT'
                );
        filter realtime.user_defined_filter;
        col_type regtype;

        in_val jsonb;
    begin
        for filter in select * from unnest(new.filters) loop
            -- Filtered column is valid
            if not filter.column_name = any(col_names) then
                raise exception 'invalid column for filter %', filter.column_name;
            end if;

            -- Type is sanitized and safe for string interpolation
            col_type = (
                select atttypid::regtype
                from pg_catalog.pg_attribute
                where attrelid = new.entity
                      and attname = filter.column_name
            );
            if col_type is null then
                raise exception 'failed to lookup type for column %', filter.column_name;
            end if;

            -- Set maximum number of entries for in filter
            if filter.op = 'in'::realtime.equality_op then
                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);
                if coalesce(jsonb_array_length(in_val), 0) > 100 then
                    raise exception 'too many values for `in` filter. Maximum 100';
                end if;
            else
                -- raises an exception if value is not coercable to type
                perform realtime.cast(filter.value, col_type);
            end if;

        end loop;

        -- Apply consistent order to filters so the unique constraint on
        -- (subscription_id, entity, filters) can't be tricked by a different filter order
        new.filters = coalesce(
            array_agg(f order by f.column_name, f.op, f.value),
            '{}'
        ) from unnest(new.filters) f;

        return new;
    end;
    $function$
"
realtime,to_regrole,role_name text,regrole,false,"CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)
 RETURNS regrole
 LANGUAGE sql
 IMMUTABLE
AS $function$ select role_name::regrole $function$
"
realtime,topic,,text,false,"CREATE OR REPLACE FUNCTION realtime.topic()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
select nullif(current_setting('realtime.topic', true), '')::text;
$function$
"
storage,can_insert_object,"bucketid text, name text, owner uuid, metadata jsonb",void,false,"CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO ""storage"".""objects"" (""bucket_id"", ""name"", ""owner"", ""metadata"") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$function$
"
storage,delete_leaf_prefixes,"bucket_ids text[], names text[]",void,true,"CREATE OR REPLACE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[])
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_rows_deleted integer;
BEGIN
    LOOP
        WITH candidates AS (
            SELECT DISTINCT
                t.bucket_id,
                unnest(storage.get_prefixes(t.name)) AS name
            FROM unnest(bucket_ids, names) AS t(bucket_id, name)
        ),
        uniq AS (
             SELECT
                 bucket_id,
                 name,
                 storage.get_level(name) AS level
             FROM candidates
             WHERE name <> ''
             GROUP BY bucket_id, name
        ),
        leaf AS (
             SELECT
                 p.bucket_id,
                 p.name,
                 p.level
             FROM storage.prefixes AS p
                  JOIN uniq AS u
                       ON u.bucket_id = p.bucket_id
                           AND u.name = p.name
                           AND u.level = p.level
             WHERE NOT EXISTS (
                 SELECT 1
                 FROM storage.objects AS o
                 WHERE o.bucket_id = p.bucket_id
                   AND o.level = p.level + 1
                   AND o.name COLLATE ""C"" LIKE p.name || '/%'
             )
             AND NOT EXISTS (
                 SELECT 1
                 FROM storage.prefixes AS c
                 WHERE c.bucket_id = p.bucket_id
                   AND c.level = p.level + 1
                   AND c.name COLLATE ""C"" LIKE p.name || '/%'
             )
        )
        DELETE
        FROM storage.prefixes AS p
            USING leaf AS l
        WHERE p.bucket_id = l.bucket_id
          AND p.name = l.name
          AND p.level = l.level;

        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;
        EXIT WHEN v_rows_deleted = 0;
    END LOOP;
END;
$function$
"
storage,enforce_bucket_name_length,,trigger,false,"CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    if length(new.name) > 100 then
        raise exception 'bucket name ""%"" is too long (% characters). Max is 100.', new.name, length(new.name);
    end if;
    return new;
end;
$function$
"
storage,extension,name text,text,false,"CREATE OR REPLACE FUNCTION storage.extension(name text)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
    _parts text[];
    _filename text;
BEGIN
    SELECT string_to_array(name, '/') INTO _parts;
    SELECT _parts[array_length(_parts,1)] INTO _filename;
    RETURN reverse(split_part(reverse(_filename), '.', 1));
END
$function$
"
storage,filename,name text,text,false,"CREATE OR REPLACE FUNCTION storage.filename(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$function$
"
storage,foldername,name text,text[],false,"CREATE OR REPLACE FUNCTION storage.foldername(name text)
 RETURNS text[]
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
    _parts text[];
BEGIN
    -- Split on ""/"" to get path segments
    SELECT string_to_array(name, '/') INTO _parts;
    -- Return everything except the last segment
    RETURN _parts[1 : array_length(_parts,1) - 1];
END
$function$
"
storage,get_common_prefix,"p_key text, p_prefix text, p_delimiter text",text,false,"CREATE OR REPLACE FUNCTION storage.get_common_prefix(p_key text, p_prefix text, p_delimiter text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
SELECT CASE
    WHEN position(p_delimiter IN substring(p_key FROM length(p_prefix) + 1)) > 0
    THEN left(p_key, length(p_prefix) + position(p_delimiter IN substring(p_key FROM length(p_prefix) + 1)))
    ELSE NULL
END;
$function$
"
storage,get_level,name text,integer,false,"CREATE OR REPLACE FUNCTION storage.get_level(name text)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
SELECT array_length(string_to_array(""name"", '/'), 1);
$function$
"
storage,get_prefix,name text,text,false,"CREATE OR REPLACE FUNCTION storage.get_prefix(name text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
SELECT
    CASE WHEN strpos(""name"", '/') > 0 THEN
             regexp_replace(""name"", '[\/]{1}[^\/]+\/?$', '')
         ELSE
             ''
        END;
$function$
"
storage,get_prefixes,name text,text[],false,"CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)
 RETURNS text[]
 LANGUAGE plpgsql
 IMMUTABLE STRICT
AS $function$
DECLARE
    parts text[];
    prefixes text[];
    prefix text;
BEGIN
    -- Split the name into parts by '/'
    parts := string_to_array(""name"", '/');
    prefixes := '{}';

    -- Construct the prefixes, stopping one level below the last part
    FOR i IN 1..array_length(parts, 1) - 1 LOOP
            prefix := array_to_string(parts[1:i], '/');
            prefixes := array_append(prefixes, prefix);
    END LOOP;

    RETURN prefixes;
END;
$function$
"
storage,get_size_by_bucket,,"TABLE(size bigint, bucket_id text)",false,"CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()
 RETURNS TABLE(size bigint, bucket_id text)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    return query
        select sum((metadata->>'size')::bigint) as size, obj.bucket_id
        from ""storage"".objects as obj
        group by obj.bucket_id;
END
$function$
"
storage,list_multipart_uploads_with_delimiter,"bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text","TABLE(key text, id text, created_at timestamp with time zone)",false,"CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)
 RETURNS TABLE(key text, id text, created_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE ""C"") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE ""C"" > $4
                            ELSE
                                key COLLATE ""C"" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE ""C"" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE ""C"" ASC, created_at ASC) as e order by key COLLATE ""C"" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$function$
"
storage,list_objects_with_delimiter,"_bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text, sort_order text","TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone)",false,"CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(_bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone)
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    v_peek_name TEXT;
    v_current RECORD;
    v_common_prefix TEXT;

    -- Configuration
    v_is_asc BOOLEAN;
    v_prefix TEXT;
    v_start TEXT;
    v_upper_bound TEXT;
    v_file_batch_size INT;

    -- Seek state
    v_next_seek TEXT;
    v_count INT := 0;

    -- Dynamic SQL for batch query only
    v_batch_query TEXT;

BEGIN
    -- ========================================================================
    -- INITIALIZATION
    -- ========================================================================
    v_is_asc := lower(coalesce(sort_order, 'asc')) = 'asc';
    v_prefix := coalesce(prefix_param, '');
    v_start := CASE WHEN coalesce(next_token, '') <> '' THEN next_token ELSE coalesce(start_after, '') END;
    v_file_batch_size := LEAST(GREATEST(max_keys * 2, 100), 1000);

    -- Calculate upper bound for prefix filtering (bytewise, using COLLATE ""C"")
    IF v_prefix = '' THEN
        v_upper_bound := NULL;
    ELSIF right(v_prefix, 1) = delimiter_param THEN
        v_upper_bound := left(v_prefix, -1) || chr(ascii(delimiter_param) + 1);
    ELSE
        v_upper_bound := left(v_prefix, -1) || chr(ascii(right(v_prefix, 1)) + 1);
    END IF;

    -- Build batch query (dynamic SQL - called infrequently, amortized over many rows)
    IF v_is_asc THEN
        IF v_upper_bound IS NOT NULL THEN
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE ""C"" >= $2 ' ||
                'AND o.name COLLATE ""C"" < $3 ORDER BY o.name COLLATE ""C"" ASC LIMIT $4';
        ELSE
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE ""C"" >= $2 ' ||
                'ORDER BY o.name COLLATE ""C"" ASC LIMIT $4';
        END IF;
    ELSE
        IF v_upper_bound IS NOT NULL THEN
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE ""C"" < $2 ' ||
                'AND o.name COLLATE ""C"" >= $3 ORDER BY o.name COLLATE ""C"" DESC LIMIT $4';
        ELSE
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE ""C"" < $2 ' ||
                'ORDER BY o.name COLLATE ""C"" DESC LIMIT $4';
        END IF;
    END IF;

    -- ========================================================================
    -- SEEK INITIALIZATION: Determine starting position
    -- ========================================================================
    IF v_start = '' THEN
        IF v_is_asc THEN
            v_next_seek := v_prefix;
        ELSE
            -- DESC without cursor: find the last item in range
            IF v_upper_bound IS NOT NULL THEN
                SELECT o.name INTO v_next_seek FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE ""C"" >= v_prefix AND o.name COLLATE ""C"" < v_upper_bound
                ORDER BY o.name COLLATE ""C"" DESC LIMIT 1;
            ELSIF v_prefix <> '' THEN
                SELECT o.name INTO v_next_seek FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE ""C"" >= v_prefix
                ORDER BY o.name COLLATE ""C"" DESC LIMIT 1;
            ELSE
                SELECT o.name INTO v_next_seek FROM storage.objects o
                WHERE o.bucket_id = _bucket_id
                ORDER BY o.name COLLATE ""C"" DESC LIMIT 1;
            END IF;

            IF v_next_seek IS NOT NULL THEN
                v_next_seek := v_next_seek || delimiter_param;
            ELSE
                RETURN;
            END IF;
        END IF;
    ELSE
        -- Cursor provided: determine if it refers to a folder or leaf
        IF EXISTS (
            SELECT 1 FROM storage.objects o
            WHERE o.bucket_id = _bucket_id
              AND o.name COLLATE ""C"" LIKE v_start || delimiter_param || '%'
            LIMIT 1
        ) THEN
            -- Cursor refers to a folder
            IF v_is_asc THEN
                v_next_seek := v_start || chr(ascii(delimiter_param) + 1);
            ELSE
                v_next_seek := v_start || delimiter_param;
            END IF;
        ELSE
            -- Cursor refers to a leaf object
            IF v_is_asc THEN
                v_next_seek := v_start || delimiter_param;
            ELSE
                v_next_seek := v_start;
            END IF;
        END IF;
    END IF;

    -- ========================================================================
    -- MAIN LOOP: Hybrid peek-then-batch algorithm
    -- Uses STATIC SQL for peek (hot path) and DYNAMIC SQL for batch
    -- ========================================================================
    LOOP
        EXIT WHEN v_count >= max_keys;

        -- STEP 1: PEEK using STATIC SQL (plan cached, very fast)
        IF v_is_asc THEN
            IF v_upper_bound IS NOT NULL THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE ""C"" >= v_next_seek AND o.name COLLATE ""C"" < v_upper_bound
                ORDER BY o.name COLLATE ""C"" ASC LIMIT 1;
            ELSE
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE ""C"" >= v_next_seek
                ORDER BY o.name COLLATE ""C"" ASC LIMIT 1;
            END IF;
        ELSE
            IF v_upper_bound IS NOT NULL THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE ""C"" < v_next_seek AND o.name COLLATE ""C"" >= v_prefix
                ORDER BY o.name COLLATE ""C"" DESC LIMIT 1;
            ELSIF v_prefix <> '' THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE ""C"" < v_next_seek AND o.name COLLATE ""C"" >= v_prefix
                ORDER BY o.name COLLATE ""C"" DESC LIMIT 1;
            ELSE
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = _bucket_id AND o.name COLLATE ""C"" < v_next_seek
                ORDER BY o.name COLLATE ""C"" DESC LIMIT 1;
            END IF;
        END IF;

        EXIT WHEN v_peek_name IS NULL;

        -- STEP 2: Check if this is a FOLDER or FILE
        v_common_prefix := storage.get_common_prefix(v_peek_name, v_prefix, delimiter_param);

        IF v_common_prefix IS NOT NULL THEN
            -- FOLDER: Emit and skip to next folder (no heap access needed)
            name := rtrim(v_common_prefix, delimiter_param);
            id := NULL;
            updated_at := NULL;
            created_at := NULL;
            last_accessed_at := NULL;
            metadata := NULL;
            RETURN NEXT;
            v_count := v_count + 1;

            -- Advance seek past the folder range
            IF v_is_asc THEN
                v_next_seek := left(v_common_prefix, -1) || chr(ascii(delimiter_param) + 1);
            ELSE
                v_next_seek := v_common_prefix;
            END IF;
        ELSE
            -- FILE: Batch fetch using DYNAMIC SQL (overhead amortized over many rows)
            -- For ASC: upper_bound is the exclusive upper limit (< condition)
            -- For DESC: prefix is the inclusive lower limit (>= condition)
            FOR v_current IN EXECUTE v_batch_query USING _bucket_id, v_next_seek,
                CASE WHEN v_is_asc THEN COALESCE(v_upper_bound, v_prefix) ELSE v_prefix END, v_file_batch_size
            LOOP
                v_common_prefix := storage.get_common_prefix(v_current.name, v_prefix, delimiter_param);

                IF v_common_prefix IS NOT NULL THEN
                    -- Hit a folder: exit batch, let peek handle it
                    v_next_seek := v_current.name;
                    EXIT;
                END IF;

                -- Emit file
                name := v_current.name;
                id := v_current.id;
                updated_at := v_current.updated_at;
                created_at := v_current.created_at;
                last_accessed_at := v_current.last_accessed_at;
                metadata := v_current.metadata;
                RETURN NEXT;
                v_count := v_count + 1;

                -- Advance seek past this file
                IF v_is_asc THEN
                    v_next_seek := v_current.name || delimiter_param;
                ELSE
                    v_next_seek := v_current.name;
                END IF;

                EXIT WHEN v_count >= max_keys;
            END LOOP;
        END IF;
    END LOOP;
END;
$function$
"
storage,operation,,text,false,"CREATE OR REPLACE FUNCTION storage.operation()
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$function$
"
storage,protect_delete,,trigger,false,"CREATE OR REPLACE FUNCTION storage.protect_delete()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Check if storage.allow_delete_query is set to 'true'
    IF COALESCE(current_setting('storage.allow_delete_query', true), 'false') != 'true' THEN
        RAISE EXCEPTION 'Direct deletion from storage tables is not allowed. Use the Storage API instead.'
            USING HINT = 'This prevents accidental data loss from orphaned objects.',
                  ERRCODE = '42501';
    END IF;
    RETURN NULL;
END;
$function$
"
storage,search,"prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text","TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",false,"CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    v_peek_name TEXT;
    v_current RECORD;
    v_common_prefix TEXT;
    v_delimiter CONSTANT TEXT := '/';

    -- Configuration
    v_limit INT;
    v_prefix TEXT;
    v_prefix_lower TEXT;
    v_is_asc BOOLEAN;
    v_order_by TEXT;
    v_sort_order TEXT;
    v_upper_bound TEXT;
    v_file_batch_size INT;

    -- Dynamic SQL for batch query only
    v_batch_query TEXT;

    -- Seek state
    v_next_seek TEXT;
    v_count INT := 0;
    v_skipped INT := 0;
BEGIN
    -- ========================================================================
    -- INITIALIZATION
    -- ========================================================================
    v_limit := LEAST(coalesce(limits, 100), 1500);
    v_prefix := coalesce(prefix, '') || coalesce(search, '');
    v_prefix_lower := lower(v_prefix);
    v_is_asc := lower(coalesce(sortorder, 'asc')) = 'asc';
    v_file_batch_size := LEAST(GREATEST(v_limit * 2, 100), 1000);

    -- Validate sort column
    CASE lower(coalesce(sortcolumn, 'name'))
        WHEN 'name' THEN v_order_by := 'name';
        WHEN 'updated_at' THEN v_order_by := 'updated_at';
        WHEN 'created_at' THEN v_order_by := 'created_at';
        WHEN 'last_accessed_at' THEN v_order_by := 'last_accessed_at';
        ELSE v_order_by := 'name';
    END CASE;

    v_sort_order := CASE WHEN v_is_asc THEN 'asc' ELSE 'desc' END;

    -- ========================================================================
    -- NON-NAME SORTING: Use path_tokens approach (unchanged)
    -- ========================================================================
    IF v_order_by != 'name' THEN
        RETURN QUERY EXECUTE format(
            $sql$
            WITH folders AS (
                SELECT path_tokens[$1] AS folder
                FROM storage.objects
                WHERE objects.name ILIKE $2 || '%%'
                  AND bucket_id = $3
                  AND array_length(objects.path_tokens, 1) <> $1
                GROUP BY folder
                ORDER BY folder %s
            )
            (SELECT folder AS ""name"",
                   NULL::uuid AS id,
                   NULL::timestamptz AS updated_at,
                   NULL::timestamptz AS created_at,
                   NULL::timestamptz AS last_accessed_at,
                   NULL::jsonb AS metadata FROM folders)
            UNION ALL
            (SELECT path_tokens[$1] AS ""name"",
                   id, updated_at, created_at, last_accessed_at, metadata
             FROM storage.objects
             WHERE objects.name ILIKE $2 || '%%'
               AND bucket_id = $3
               AND array_length(objects.path_tokens, 1) = $1
             ORDER BY %I %s)
            LIMIT $4 OFFSET $5
            $sql$, v_sort_order, v_order_by, v_sort_order
        ) USING levels, v_prefix, bucketname, v_limit, offsets;
        RETURN;
    END IF;

    -- ========================================================================
    -- NAME SORTING: Hybrid skip-scan with batch optimization
    -- ========================================================================

    -- Calculate upper bound for prefix filtering
    IF v_prefix_lower = '' THEN
        v_upper_bound := NULL;
    ELSIF right(v_prefix_lower, 1) = v_delimiter THEN
        v_upper_bound := left(v_prefix_lower, -1) || chr(ascii(v_delimiter) + 1);
    ELSE
        v_upper_bound := left(v_prefix_lower, -1) || chr(ascii(right(v_prefix_lower, 1)) + 1);
    END IF;

    -- Build batch query (dynamic SQL - called infrequently, amortized over many rows)
    IF v_is_asc THEN
        IF v_upper_bound IS NOT NULL THEN
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE ""C"" >= $2 ' ||
                'AND lower(o.name) COLLATE ""C"" < $3 ORDER BY lower(o.name) COLLATE ""C"" ASC LIMIT $4';
        ELSE
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE ""C"" >= $2 ' ||
                'ORDER BY lower(o.name) COLLATE ""C"" ASC LIMIT $4';
        END IF;
    ELSE
        IF v_upper_bound IS NOT NULL THEN
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE ""C"" < $2 ' ||
                'AND lower(o.name) COLLATE ""C"" >= $3 ORDER BY lower(o.name) COLLATE ""C"" DESC LIMIT $4';
        ELSE
            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||
                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE ""C"" < $2 ' ||
                'ORDER BY lower(o.name) COLLATE ""C"" DESC LIMIT $4';
        END IF;
    END IF;

    -- Initialize seek position
    IF v_is_asc THEN
        v_next_seek := v_prefix_lower;
    ELSE
        -- DESC: find the last item in range first (static SQL)
        IF v_upper_bound IS NOT NULL THEN
            SELECT o.name INTO v_peek_name FROM storage.objects o
            WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE ""C"" >= v_prefix_lower AND lower(o.name) COLLATE ""C"" < v_upper_bound
            ORDER BY lower(o.name) COLLATE ""C"" DESC LIMIT 1;
        ELSIF v_prefix_lower <> '' THEN
            SELECT o.name INTO v_peek_name FROM storage.objects o
            WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE ""C"" >= v_prefix_lower
            ORDER BY lower(o.name) COLLATE ""C"" DESC LIMIT 1;
        ELSE
            SELECT o.name INTO v_peek_name FROM storage.objects o
            WHERE o.bucket_id = bucketname
            ORDER BY lower(o.name) COLLATE ""C"" DESC LIMIT 1;
        END IF;

        IF v_peek_name IS NOT NULL THEN
            v_next_seek := lower(v_peek_name) || v_delimiter;
        ELSE
            RETURN;
        END IF;
    END IF;

    -- ========================================================================
    -- MAIN LOOP: Hybrid peek-then-batch algorithm
    -- Uses STATIC SQL for peek (hot path) and DYNAMIC SQL for batch
    -- ========================================================================
    LOOP
        EXIT WHEN v_count >= v_limit;

        -- STEP 1: PEEK using STATIC SQL (plan cached, very fast)
        IF v_is_asc THEN
            IF v_upper_bound IS NOT NULL THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE ""C"" >= v_next_seek AND lower(o.name) COLLATE ""C"" < v_upper_bound
                ORDER BY lower(o.name) COLLATE ""C"" ASC LIMIT 1;
            ELSE
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE ""C"" >= v_next_seek
                ORDER BY lower(o.name) COLLATE ""C"" ASC LIMIT 1;
            END IF;
        ELSE
            IF v_upper_bound IS NOT NULL THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE ""C"" < v_next_seek AND lower(o.name) COLLATE ""C"" >= v_prefix_lower
                ORDER BY lower(o.name) COLLATE ""C"" DESC LIMIT 1;
            ELSIF v_prefix_lower <> '' THEN
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE ""C"" < v_next_seek AND lower(o.name) COLLATE ""C"" >= v_prefix_lower
                ORDER BY lower(o.name) COLLATE ""C"" DESC LIMIT 1;
            ELSE
                SELECT o.name INTO v_peek_name FROM storage.objects o
                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE ""C"" < v_next_seek
                ORDER BY lower(o.name) COLLATE ""C"" DESC LIMIT 1;
            END IF;
        END IF;

        EXIT WHEN v_peek_name IS NULL;

        -- STEP 2: Check if this is a FOLDER or FILE
        v_common_prefix := storage.get_common_prefix(lower(v_peek_name), v_prefix_lower, v_delimiter);

        IF v_common_prefix IS NOT NULL THEN
            -- FOLDER: Handle offset, emit if needed, skip to next folder
            IF v_skipped < offsets THEN
                v_skipped := v_skipped + 1;
            ELSE
                name := split_part(rtrim(storage.get_common_prefix(v_peek_name, v_prefix, v_delimiter), v_delimiter), v_delimiter, levels);
                id := NULL;
                updated_at := NULL;
                created_at := NULL;
                last_accessed_at := NULL;
                metadata := NULL;
                RETURN NEXT;
                v_count := v_count + 1;
            END IF;

            -- Advance seek past the folder range
            IF v_is_asc THEN
                v_next_seek := lower(left(v_common_prefix, -1)) || chr(ascii(v_delimiter) + 1);
            ELSE
                v_next_seek := lower(v_common_prefix);
            END IF;
        ELSE
            -- FILE: Batch fetch using DYNAMIC SQL (overhead amortized over many rows)
            -- For ASC: upper_bound is the exclusive upper limit (< condition)
            -- For DESC: prefix_lower is the inclusive lower limit (>= condition)
            FOR v_current IN EXECUTE v_batch_query
                USING bucketname, v_next_seek,
                    CASE WHEN v_is_asc THEN COALESCE(v_upper_bound, v_prefix_lower) ELSE v_prefix_lower END, v_file_batch_size
            LOOP
                v_common_prefix := storage.get_common_prefix(lower(v_current.name), v_prefix_lower, v_delimiter);

                IF v_common_prefix IS NOT NULL THEN
                    -- Hit a folder: exit batch, let peek handle it
                    v_next_seek := lower(v_current.name);
                    EXIT;
                END IF;

                -- Handle offset skipping
                IF v_skipped < offsets THEN
                    v_skipped := v_skipped + 1;
                ELSE
                    -- Emit file
                    name := split_part(v_current.name, v_delimiter, levels);
                    id := v_current.id;
                    updated_at := v_current.updated_at;
                    created_at := v_current.created_at;
                    last_accessed_at := v_current.last_accessed_at;
                    metadata := v_current.metadata;
                    RETURN NEXT;
                    v_count := v_count + 1;
                END IF;

                -- Advance seek past this file
                IF v_is_asc THEN
                    v_next_seek := lower(v_current.name) || v_delimiter;
                ELSE
                    v_next_seek := lower(v_current.name);
                END IF;

                EXIT WHEN v_count >= v_limit;
            END LOOP;
        END IF;
    END LOOP;
END;
$function$
"
storage,search_by_timestamp,"p_prefix text, p_bucket_id text, p_limit integer, p_level integer, p_start_after text, p_sort_order text, p_sort_column text, p_sort_column_after text","TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",false,"CREATE OR REPLACE FUNCTION storage.search_by_timestamp(p_prefix text, p_bucket_id text, p_limit integer, p_level integer, p_start_after text, p_sort_order text, p_sort_column text, p_sort_column_after text)
 RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    v_cursor_op text;
    v_query text;
    v_prefix text;
BEGIN
    v_prefix := coalesce(p_prefix, '');

    IF p_sort_order = 'asc' THEN
        v_cursor_op := '>';
    ELSE
        v_cursor_op := '<';
    END IF;

    v_query := format($sql$
        WITH raw_objects AS (
            SELECT
                o.name AS obj_name,
                o.id AS obj_id,
                o.updated_at AS obj_updated_at,
                o.created_at AS obj_created_at,
                o.last_accessed_at AS obj_last_accessed_at,
                o.metadata AS obj_metadata,
                storage.get_common_prefix(o.name, $1, '/') AS common_prefix
            FROM storage.objects o
            WHERE o.bucket_id = $2
              AND o.name COLLATE ""C"" LIKE $1 || '%%'
        ),
        -- Aggregate common prefixes (folders)
        -- Both created_at and updated_at use MIN(obj_created_at) to match the old prefixes table behavior
        aggregated_prefixes AS (
            SELECT
                rtrim(common_prefix, '/') AS name,
                NULL::uuid AS id,
                MIN(obj_created_at) AS updated_at,
                MIN(obj_created_at) AS created_at,
                NULL::timestamptz AS last_accessed_at,
                NULL::jsonb AS metadata,
                TRUE AS is_prefix
            FROM raw_objects
            WHERE common_prefix IS NOT NULL
            GROUP BY common_prefix
        ),
        leaf_objects AS (
            SELECT
                obj_name AS name,
                obj_id AS id,
                obj_updated_at AS updated_at,
                obj_created_at AS created_at,
                obj_last_accessed_at AS last_accessed_at,
                obj_metadata AS metadata,
                FALSE AS is_prefix
            FROM raw_objects
            WHERE common_prefix IS NULL
        ),
        combined AS (
            SELECT * FROM aggregated_prefixes
            UNION ALL
            SELECT * FROM leaf_objects
        ),
        filtered AS (
            SELECT *
            FROM combined
            WHERE (
                $5 = ''
                OR ROW(
                    date_trunc('milliseconds', %I),
                    name COLLATE ""C""
                ) %s ROW(
                    COALESCE(NULLIF($6, '')::timestamptz, 'epoch'::timestamptz),
                    $5
                )
            )
        )
        SELECT
            split_part(name, '/', $3) AS key,
            name,
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
        FROM filtered
        ORDER BY
            COALESCE(date_trunc('milliseconds', %I), 'epoch'::timestamptz) %s,
            name COLLATE ""C"" %s
        LIMIT $4
    $sql$,
        p_sort_column,
        v_cursor_op,
        p_sort_column,
        p_sort_order,
        p_sort_order
    );

    RETURN QUERY EXECUTE v_query
    USING v_prefix, p_bucket_id, p_level, p_limit, p_start_after, p_sort_column_after;
END;
$function$
"
storage,search_legacy_v1,"prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text","TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",false,"CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select path_tokens[$1] as folder
           from storage.objects
             where objects.name ilike $2 || $3 || ''%''
               and bucket_id = $4
               and array_length(objects.path_tokens, 1) <> $1
           group by folder
           order by folder ' || v_sort_order || '
     )
     (select folder as ""name"",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as ""name"",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$function$
"
storage,search_v2,"prefix text, bucket_name text, limits integer, levels integer, start_after text, sort_order text, sort_column text, sort_column_after text","TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",false,"CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text)
 RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    v_sort_col text;
    v_sort_ord text;
    v_limit int;
BEGIN
    -- Cap limit to maximum of 1500 records
    v_limit := LEAST(coalesce(limits, 100), 1500);

    -- Validate and normalize sort_order
    v_sort_ord := lower(coalesce(sort_order, 'asc'));
    IF v_sort_ord NOT IN ('asc', 'desc') THEN
        v_sort_ord := 'asc';
    END IF;

    -- Validate and normalize sort_column
    v_sort_col := lower(coalesce(sort_column, 'name'));
    IF v_sort_col NOT IN ('name', 'updated_at', 'created_at') THEN
        v_sort_col := 'name';
    END IF;

    -- Route to appropriate implementation
    IF v_sort_col = 'name' THEN
        -- Use list_objects_with_delimiter for name sorting (most efficient: O(k * log n))
        RETURN QUERY
        SELECT
            split_part(l.name, '/', levels) AS key,
            l.name AS name,
            l.id,
            l.updated_at,
            l.created_at,
            l.last_accessed_at,
            l.metadata
        FROM storage.list_objects_with_delimiter(
            bucket_name,
            coalesce(prefix, ''),
            '/',
            v_limit,
            start_after,
            '',
            v_sort_ord
        ) l;
    ELSE
        -- Use aggregation approach for timestamp sorting
        -- Not efficient for large datasets but supports correct pagination
        RETURN QUERY SELECT * FROM storage.search_by_timestamp(
            prefix, bucket_name, v_limit, levels, start_after,
            v_sort_ord, v_sort_col, sort_column_after
        );
    END IF;
END;
$function$
"
storage,update_updated_at_column,,trigger,false,"CREATE OR REPLACE FUNCTION storage.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$function$
"
supabase_functions,http_request,,trigger,true,"CREATE OR REPLACE FUNCTION supabase_functions.http_request()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'supabase_functions'
AS $function$
    DECLARE
      request_id bigint;
      payload jsonb;
      url text := TG_ARGV[0]::text;
      method text := TG_ARGV[1]::text;
      headers jsonb DEFAULT '{}'::jsonb;
      params jsonb DEFAULT '{}'::jsonb;
      timeout_ms integer DEFAULT 1000;
    BEGIN
      IF url IS NULL OR url = 'null' THEN
        RAISE EXCEPTION 'url argument is missing';
      END IF;

      IF method IS NULL OR method = 'null' THEN
        RAISE EXCEPTION 'method argument is missing';
      END IF;

      IF TG_ARGV[2] IS NULL OR TG_ARGV[2] = 'null' THEN
        headers = '{""Content-Type"": ""application/json""}'::jsonb;
      ELSE
        headers = TG_ARGV[2]::jsonb;
      END IF;

      IF TG_ARGV[3] IS NULL OR TG_ARGV[3] = 'null' THEN
        params = '{}'::jsonb;
      ELSE
        params = TG_ARGV[3]::jsonb;
      END IF;

      IF TG_ARGV[4] IS NULL OR TG_ARGV[4] = 'null' THEN
        timeout_ms = 1000;
      ELSE
        timeout_ms = TG_ARGV[4]::integer;
      END IF;

      CASE
        WHEN method = 'GET' THEN
          SELECT http_get INTO request_id FROM net.http_get(
            url,
            params,
            headers,
            timeout_ms
          );
        WHEN method = 'POST' THEN
          payload = jsonb_build_object(
            'old_record', OLD,
            'record', NEW,
            'type', TG_OP,
            'table', TG_TABLE_NAME,
            'schema', TG_TABLE_SCHEMA
          );

          SELECT http_post INTO request_id FROM net.http_post(
            url,
            payload,
            params,
            headers,
            timeout_ms
          );
        ELSE
          RAISE EXCEPTION 'method argument % is invalid', method;
      END CASE;

      INSERT INTO supabase_functions.hooks
        (hook_table_id, hook_name, request_id)
      VALUES
        (TG_RELID, TG_NAME, request_id);

      RETURN NEW;
    END
  $function$
"
vault,_crypto_aead_det_decrypt,"message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",bytea,false,"CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$
"
vault,_crypto_aead_det_encrypt,"message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",bytea,false,"CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$
"
vault,_crypto_aead_det_noncegen,,bytea,false,"CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$
"
vault,create_secret,"new_secret text, new_name text, new_description text, new_key_id uuid",uuid,true,"CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  rec record;
BEGIN
  INSERT INTO vault.secrets (secret, name, description)
  VALUES (
    new_secret,
    new_name,
    new_description
  )
  RETURNING * INTO rec;
  UPDATE vault.secrets s
  SET secret = encode(vault._crypto_aead_det_encrypt(
    message := convert_to(rec.secret, 'utf8'),
    additional := convert_to(s.id::text, 'utf8'),
    key_id := 0,
    context := 'pgsodium'::bytea,
    nonce := rec.nonce
  ), 'base64')
  WHERE id = rec.id;
  RETURN rec.id;
END
$function$
"
vault,update_secret,"secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid",void,true,"CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);
BEGIN
  UPDATE vault.secrets s
  SET
    secret = CASE WHEN new_secret IS NULL THEN s.secret
                  ELSE encode(vault._crypto_aead_det_encrypt(
                    message := convert_to(new_secret, 'utf8'),
                    additional := convert_to(s.id::text, 'utf8'),
                    key_id := 0,
                    context := 'pgsodium'::bytea,
                    nonce := s.nonce
                  ), 'base64') END,
    name = coalesce(new_name, s.name),
    description = coalesce(new_description, s.description),
    updated_at = now()
  WHERE s.id = secret_id;
END
$function$
"